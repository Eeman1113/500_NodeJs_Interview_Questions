Category,Question,Answer
I. Fundamentals,1. What is Node.js?,Node.js is a back-end JavaScript runtime environment that runs on the V8 engine and executes JavaScript code outside a web browser.
,2. Why use Node.js?,"Node.js is used for its non-blocking, event-driven architecture, which makes it efficient and lightweight for building scalable network applications. It also allows developers to use JavaScript for both front-end and back-end development."
,3. How does Node.js work?,"Node.js works on a single-threaded event loop. It uses non-blocking I/O operations to handle multiple concurrent requests efficiently. When a request is made, it's processed in the event loop, and if it's an I/O operation, Node.js delegates it to the system's kernel and continues to process other requests."
,4. What is the V8 engine?,"The V8 engine is an open-source, high-performance JavaScript and WebAssembly engine written in C++. It is developed by Google and is used in Google Chrome and Node.js, among others."
,5. Is Node.js single-threaded or multi-threaded?,"Node.js is single-threaded. It uses a single thread to execute JavaScript code, which simplifies programming by avoiding the complexities of multi-threading. However, it uses a thread pool for handling I/O operations, which allows it to perform non-blocking I/O concurrently."
,6. Explain the concept of non-blocking I/O.,"Non-blocking I/O (Input/Output) is a form of I/O that does not block the execution of a program. In Node.js, when a program requests an I/O operation, it doesn't wait for the operation to complete. Instead, it continues to execute other code and is notified via a callback when the I/O operation is finished."
,7. What is the event loop?,"The event loop is a core part of Node.js that allows it to perform non-blocking I/O operations. It's a loop that continuously checks for and processes events from the event queue, such as I/O operations, timers, and user-initiated events."
,8. What is npm?,"npm (Node Package Manager) is the default package manager for Node.js. It is used to install, manage, and share reusable JavaScript code packages (modules)."
,9. What is the purpose of the package.json file?,"The package.json file is a manifest file for a Node.js project. It contains metadata about the project, such as its name, version, and dependencies, as well as scripts for automating tasks."
,10. How do you install a package using npm?,"To install a package using npm, you use the npm install command followed by the package name, like this: npm install <package-name>."
,11. What is the difference between dependencies and devDependencies?,"dependencies are packages that are required for the application to run in production, while devDependencies are packages that are only needed for development and testing, such as testing frameworks and build tools."
,12. What is the node_modules directory?,The node_modules directory is where npm installs the packages that your project depends on. Each package has its own subdirectory within node_modules.
,13. How do you run a Node.js script from the command line?,"To run a Node.js script from the command line, you use the node command followed by the path to the script file, like this: node <script-file>.js."
,14. What is the require() function?,The require() function is a built-in function in Node.js that is used to import modules. It takes a module identifier as an argument and returns the module.exports object of that module.
,15. What are modules in Node.js?,Modules in Node.js are reusable blocks of code that can be imported into other files. Each file in a Node.js application is treated as a separate module.
,"16. What is the difference between core modules, local modules, and third-party modules?","Core modules are built-in modules that come with Node.js, such as fs and http. Local modules are modules that you create within your own project. Third-party modules are modules that are created by other developers and are available on the npm registry."
,17. How do you export a module?,"You can export a module by assigning a value to the module.exports object. This can be a function, an object, a class, or any other JavaScript value."
,18. What is the module.exports object?,module.exports is an object that is created by the Node.js module system. It is used to export values from a module so that they can be used in other parts of the application.
,19. What is the difference between module.exports and exports?,"module.exports is a reference to the actual object that is returned by the require() function, while exports is a shorthand for module.exports. If you reassign exports to a new value, it will no longer be a reference to module.exports."
,20. How do you create a simple HTTP server in Node.js?,You can create a simple HTTP server in Node.js using the http module. You use the http.createServer() method to create a server and then call the listen() method to start listening for requests.
,21. What are the request and response objects in an HTTP server?,"The request object represents an incoming HTTP request and contains information about the request, such as the URL, headers, and body. The response object represents the outgoing HTTP response and is used to send data back to the client."
,22. How do you read environment variables in Node.js?,You can read environment variables in Node.js using the process.env object. This object contains all the environment variables that are available to the current process.
,23. What is the process object?,"The process object is a global object in Node.js that provides information about and control over the current Node.js process. It contains properties and methods for interacting with the process, such as process.env, process.argv, and process.exit()."
,24. How do you exit a Node.js application?,You can exit a Node.js application by calling the process.exit() method. You can optionally pass an exit code as an argument to indicate whether the application exited successfully or with an error.
,25. What is REPL?,REPL (Read-Eval-Print Loop) is an interactive shell for Node.js that allows you to execute JavaScript code and see the results immediately. It is useful for testing and debugging code snippets.
,26. What does __dirname and __filename represent?,"__dirname is a string that represents the directory name of the current module. __filename is a string that represents the file name of the current module, including the full path."
,27. How do you handle command-line arguments in Node.js?,"You can handle command-line arguments in Node.js using the process.argv array. This array contains all the command-line arguments that were passed to the Node.js process, including the path to the Node.js executable and the script file."
,28. What are arrow functions?,"Arrow functions are a concise way to write functions in JavaScript. They are defined using the => syntax and have a lexical this binding, which means that this refers to the this of the enclosing scope."
,29. Explain the difference between == and ===.,"The == operator performs a loose equality comparison, which means that it will try to coerce the operands to the same type before comparing them. The === operator performs a strict equality comparison, which means that it will only return true if the operands have the same type and value."
,30. What are template literals?,Template literals are a way to create strings in JavaScript that can contain embedded expressions. They are enclosed in backticks (`) and can span multiple lines.
II. Asynchronous Programming,31. What is asynchronous programming?,"Asynchronous programming is a programming paradigm that allows a program to perform multiple tasks at the same time without blocking the execution of the main thread. In Node.js, this is achieved through the use of callbacks, Promises, and async/await."
,32. Why is asynchronous programming important in Node.js?,Asynchronous programming is important in Node.js because it allows the server to handle a large number of concurrent connections without getting blocked by I/O operations. This makes Node.js applications highly scalable and efficient.
,33. What are callbacks?,Callbacks are functions that are passed as arguments to other functions and are executed after the outer function has completed. They are used in Node.js to handle asynchronous operations.
,"34. What is ""callback hell"" or the ""pyramid of doom""?","Callback hell is a situation where you have multiple nested callbacks, which can make the code difficult to read and maintain. This often happens when you have a series of asynchronous operations that depend on each other."
,35. How can you avoid callback hell?,"You can avoid callback hell by using Promises or async/await. Promises provide a more structured way to handle asynchronous operations, while async/await allows you to write asynchronous code that looks and feels like synchronous code."
,36. What are Promises?,"Promises are objects that represent the eventual completion or failure of an asynchronous operation. They can be in one of three states: pending, fulfilled, or rejected."
,37. What are the three states of a Promise?,"The three states of a Promise are: pending (the initial state), fulfilled (the operation completed successfully), and rejected (the operation failed)."
,38. How do you create a Promise?,"You can create a Promise using the Promise constructor, which takes a function as an argument. This function, in turn, takes two arguments: a resolve function and a reject function."
,"39. What is the purpose of .then(), .catch(), and .finally()?",.then() is used to schedule a callback to be executed when the Promise is fulfilled. .catch() is used to schedule a callback to be executed when the Promise is rejected. .finally() is used to schedule a callback to be executed when the Promise is settled (either fulfilled or rejected).
,40. What is async/await?,"async/await is a syntactic sugar on top of Promises that allows you to write asynchronous code in a more synchronous-looking way. The async keyword is used to declare a function as asynchronous, and the await keyword is used to pause the execution of the function until a Promise is settled."
,41. What are the benefits of using async/await over Promises?,"The main benefits of using async/await over Promises are improved readability and error handling. async/await makes the code look more linear and easier to follow, and it allows you to use try...catch blocks to handle errors in a more familiar way."
,42. How do you handle errors in async/await?,You can handle errors in async/await using try...catch blocks. You wrap the await expression in a try block and catch any errors in a catch block.
,43. Can you use await outside of an async function?,"In most JavaScript environments, you cannot use await outside of an async function. However, top-level await is now a feature in modern versions of Node.js and browsers, allowing you to use await at the top level of a module."
,44. What is the EventEmitter class?,The EventEmitter class is a built-in class in Node.js that allows you to create and listen for custom events. It is the foundation of Node.js's event-driven architecture.
,45. How do you create and listen to custom events?,You can create a custom event emitter by extending the EventEmitter class. You can then use the emit() method to fire an event and the on() method to listen for an event.
,46. Explain the different phases of the event loop.,"The event loop has several phases, including timers, pending callbacks, idle/prepare, poll, check, and close callbacks. Each phase has its own queue of callbacks to execute."
,"47. What is the difference between setImmediate(), setTimeout(), and process.nextTick()?","setTimeout() schedules a callback to be executed after a specified delay. setImmediate() schedules a callback to be executed in the check phase of the event loop. process.nextTick() schedules a callback to be executed at the beginning of the next event loop tick, before any other I/O events."
,48. When would you use process.nextTick()?,You would use process.nextTick() when you want to execute a function immediately after the current function completes but before the event loop continues. This can be useful for breaking up long-running tasks and preventing the event loop from being blocked.
,49. What are microtasks and macrotasks?,"Microtasks are tasks that are executed at the end of the current event loop tick, such as process.nextTick() callbacks and Promise resolutions. Macrotasks are tasks that are executed in a separate event loop tick, such as setTimeout() callbacks and I/O events."
,50. How does the event loop handle microtasks and macrotasks?,The event loop processes microtasks before it processes macrotasks. This means that all the microtasks in the microtask queue will be executed before any of the macrotasks in the macrotask queue.
,51. Explain how to use the async library for flow control.,"The async library provides a number of functions for managing asynchronous control flow, such as async.series(), async.parallel(), and async.waterfall(). These functions can help you to avoid callback hell and write more readable asynchronous code."
,52. What are some common patterns for managing asynchronous operations?,"Some common patterns for managing asynchronous operations include callbacks, Promises, async/await, and the async library. The best pattern to use depends on the specific needs of your application."
,53. How do you convert a callback-based function to a Promise-based function?,You can convert a callback-based function to a Promise-based function using the util.promisify() function in Node.js. This function takes a callback-based function as an argument and returns a new function that returns a Promise.
,54. What is the purpose of Promise.all()?,Promise.all() takes an array of Promises as input and returns a single Promise that fulfills when all of the input Promises have fulfilled. It is useful for when you want to perform multiple asynchronous operations in parallel and wait for all of them to complete.
,55. What is the difference between Promise.all() and Promise.race()?,"Promise.all() fulfills when all of the input Promises have fulfilled, while Promise.race() fulfills or rejects as soon as one of the input Promises fulfills or rejects."
,56. What is Promise.allSettled()?,"Promise.allSettled() takes an array of Promises as input and returns a single Promise that fulfills when all of the input Promises have settled (either fulfilled or rejected). It is useful for when you want to know the outcome of each Promise, regardless of whether it was fulfilled or rejected."
,57. What are Promise.any() and Promise.resolve()/Promise.reject()?,Promise.any() takes an array of Promises as input and returns a single Promise that fulfills as soon as one of the input Promises fulfills. Promise.resolve() returns a Promise that is resolved with a given value. Promise.reject() returns a Promise that is rejected with a given reason.
,58. How do you handle unhandled promise rejections?,You can handle unhandled promise rejections by adding a .catch() block to the end of your Promise chain or by listening for the unhandledRejection event on the process object.
,59. What are async iterators and for-await-of loops?,"Async iterators are a special type of iterator that can be used to iterate over asynchronous data sources, such as streams. The for-await-of loop is a new type of loop that can be used to iterate over async iterators in a synchronous-looking way."
III. Modules and Packages,60. What is CommonJS?,CommonJS is a module formatting system and standard used in Node.js to structure and organize JavaScript code. It defines a module scope where variables are private by default and uses require to import modules and module.exports to export them.
,61. How does require() resolve modules?,"require() resolves modules in the following order: 1. Core Modules: If the module name is a core Node.js module (e.g., http, fs), it returns that module. 2. File Modules: If the name starts with ./, ../, or /, it's treated as a file path. Node.js looks for the file (.js, .json, .node). 3. npm Modules: If it's a bare name (e.g., express), Node.js looks for it in the node_modules directory, starting from the current directory and moving up to the root."
,62. What is the module cache?,"Node.js caches modules after the first time they are loaded. When require('module') is called, the resolved module is stored in require.cache. Subsequent calls to require('module') will return the cached version, which improves performance and ensures that the same instance of a module is returned every time."
,63. How can you create private members in a module?,"In CommonJS, variables and functions declared within a module file are private by default. They are not accessible from outside the module unless they are explicitly attached to the module.exports or exports object."
,64. What is the purpose of the main field in package.json?,"The main field in package.json specifies the entry point to your application. When your package is required by another module (e.g., require('my-package')), the file specified in the main field is the one that gets exported. If not set, it defaults to index.js."
,65. What is npm install --save vs npm install --save-dev?,"npm install --save (or npm i <package>) installs a package and adds it to the dependencies in package.json. These are needed for the application to run in production. npm install --save-dev (or npm i -D <package>) installs a package and adds it to the devDependencies. These are only needed for development, like linters or testing libraries."
,66. What does npm init do?,"npm init creates a package.json file for your project. It runs a command-line utility that prompts you for information about the project (name, version, description, etc.) and generates the file based on your answers. Using npm init -y will skip the questions and generate a default package.json."
,67. What is the package-lock.json file?,"The package-lock.json file is automatically generated for any operations where npm modifies either the node_modules tree or package.json. It records the exact version of every installed dependency, including sub-dependencies, ensuring that the same dependency tree is installed every time."
,68. Why is package-lock.json important?,"It guarantees deterministic installs across different machines and environments. By locking down the specific versions of all packages, it prevents unexpected breakages caused by dependency updates and ensures that developers and CI/CD systems are all working with the identical set of dependencies."
,69. What is semantic versioning (SemVer)?,Semantic Versioning (SemVer) is a versioning scheme that uses a three-part version number: MAJOR.MINOR.PATCH. MAJOR version changes indicate incompatible API changes. MINOR version changes add functionality in a backward-compatible manner. PATCH version changes are for backward-compatible bug fixes.
,70. Explain the meaning of ~ and ^ in package.json.,"The tilde (~) allows patch-level changes. ~1.2.3 will match versions from 1.2.3 up to, but not including, 1.3.0. The caret (^) allows minor-level changes. ^1.2.3 will match versions from 1.2.3 up to, but not including, 2.0.0. The caret is the default when installing packages."
,71. What is npm ci and how is it different from npm install?,"npm ci (clean install) is used for automated environments like CI/CD pipelines. It installs dependencies directly from package-lock.json instead of package.json. It is faster, stricter, and more reliable for creating reproducible builds. Unlike npm install, it deletes the existing node_modules directory first and will fail if the package-lock.json is out of sync with package.json."
,72. Explain the difference between CommonJS and ES Modules (import/export).,"CommonJS (require/module.exports): Synchronous (loads modules one by one), dynamic (can be called anywhere), and the default in Node.js for .js files. ES Modules (import/export): Asynchronous, static (imports are hoisted and must be at the top level), and the standard for modern JavaScript."
,73. How do you use ES Modules in Node.js?,"You can use ES Modules in Node.js by either: 1. Setting ""type"": ""module"" in your package.json file, which makes all .js files in the project be treated as ES Modules. 2. Using the .mjs file extension for your module files."
,"74. What is the ""type"": ""module"" field in package.json?","The ""type"": ""module"" field in package.json tells Node.js to treat all .js files in the project as ES Modules. This enables the use of import and export syntax by default. If this is set, CommonJS files should be named with a .cjs extension."
,75. Can you use require() in an ES module?,"No, you cannot directly use the require() function in a standard ES module. You must use the import syntax. However, you can use createRequire from the module core module to create a require function if you need to load a CommonJS module."
,76. Can you use import in a CommonJS module?,"You cannot use the static import statement in a CommonJS module. However, you can use the dynamic import() function, which returns a promise, to asynchronously load an ES module."
,77. What are circular dependencies and how can you deal with them?,"A circular dependency occurs when module A requires module B, and module B in turn requires module A. Node.js handles this by returning an unfinished copy of the module during the circular require call. To deal with them, you should refactor your code to break the cycle, often by moving shared functionality to a third module."
,78. What is npm link used for?,"npm link allows you to develop and test a local package without having to publish it to the npm registry. It creates a symbolic link from your global node_modules directory to your local package directory, and then you can link that package into another project to use it as if it were a regular dependency."
,"79. What are npx, npm scripts, and their use cases?","npx: A package runner tool that comes with npm. It allows you to execute command-line packages from the npm registry without installing them globally or locally. npm scripts: Defined in the scripts section of package.json, they are used to automate repetitive tasks like testing (npm test), starting a server (npm start), or building the project (npm run build)."
,80. How do you publish a package to the npm registry?,"First, you need an npm account and to be logged in via npm login. Then, ensure your package.json is correctly configured. Finally, run npm publish from your package's root directory. The package name must be unique on the npm registry."
,81. What are scoped packages?,"Scoped packages are a way to group related npm packages under a namespace or ""scope,"" which is usually your npm username or organization name (e.g., @myscope/mypackage). They help prevent naming conflicts and can be used to create private packages."
,82. What is the purpose of a .npmrc file?,"The .npmrc file is used to configure npm settings. It can be used to set up private registries, authentication tokens, proxy settings, or other configuration options for a project or globally for a user."
IV. Error Handling,83. How do you handle synchronous errors in Node.js?,Synchronous errors are handled using the standard try...catch block. You place the code that might throw an error inside the try block and the error-handling logic inside the catch block.
,84. How do you handle asynchronous errors with callbacks?,"The convention for callbacks is to use ""error-first callbacks,"" where the first argument to the callback function is reserved for an error object. If an error occurs, it's passed as the first argument; otherwise, the first argument is null."
,85. How do you handle errors with Promises?,Errors in Promises are handled using the .catch() method at the end of a promise chain. Any error thrown (or promise rejected) in the chain will be caught by the .catch() block.
,86. How do you handle errors with async/await?,"With async/await, you can use the traditional try...catch block, just like with synchronous code. You wrap the await call (which might reject) in a try block and handle the potential error in the corresponding catch block."
,87. What happens if an error is not caught in a Promise chain?,"If a Promise is rejected and it doesn't have a .catch() handler, it becomes an ""unhandled promise rejection."" In modern versions of Node.js, this will cause the application to terminate. In older versions, it would just log a warning."
,88. What is an uncaughtException event?,"The process.on('uncaughtException', ...) event is emitted when a synchronous error is thrown but not caught anywhere in a try...catch block. It is a last-resort mechanism for handling unexpected errors."
,89. Why is it generally not recommended to use process.on('uncaughtException') to keep the application running?,Using uncaughtException to resume normal operation is unsafe because the application's state becomes unreliable and unpredictable. It should only be used for synchronous cleanup of resources (like logging the error) before gracefully shutting down the process.
,90. What is an unhandledRejection event?,"The process.on('unhandledRejection', ...) event is emitted whenever a Promise is rejected and no error handler is attached to it. It's the asynchronous equivalent of uncaughtException."
,91. Differentiate between operational errors and programmer errors.,"Operational Errors: These are runtime problems that are expected (e.g., failed to connect to a database, invalid user input, network request timeout). They should be handled gracefully. Programmer Errors: These are bugs in the code (e.g., reading a property of undefined, syntax error). They are unexpected and often require the application to be restarted."
,92. What are some best practices for error handling in Node.js applications?,"Use try...catch for sync code and .catch() or try...catch with async/await for async code. Use error-first callbacks. Centralize error handling (e.g., in Express middleware). Create custom error classes. Log errors effectively. Gracefully shut down on programmer errors."
,93. How can you create custom error classes?,You can create custom error classes by extending the built-in Error class. This allows you to add custom properties (like status codes or error types) and use instanceof to check for specific types of errors.
,94. Explain the concept of error-first callbacks.,"An error-first callback is a pattern where the callback function's first argument is reserved for an error object. If no error occurred, this argument is null or undefined. Subsequent arguments contain the successful result data. This standardizes error handling in asynchronous callback-based code."
,95. How can you centralize error handling in an Express.js application?,"In Express, you can create a special error-handling middleware function that takes four arguments: (err, req, res, next). This middleware is placed at the end of the middleware stack and will catch any errors passed to next(err) or thrown in route handlers."
,96. What is the purpose of a domain for error handling (and why is it deprecated)?,"The domain module was created to try and contain errors within a specific context or ""domain."" It was intended to handle errors in a way that wouldn't crash the entire application. However, it was found to be unreliable and complex, and it has been deprecated in favor of more predictable error handling patterns."
,97. How can you gracefully shut down a Node.js application on an unrecoverable error?,"On an unrecoverable error (like an uncaught exception), you should perform necessary cleanup (log the error, close database connections, etc.) and then exit the process using process.exit(1). Using a process manager like PM2 can then automatically restart the application."
,98. What are some common sources of errors in a Node.js application?,"Common sources include invalid user input, network errors (e.g., API failures, DNS issues), database errors (connection failures, query errors), file system errors (file not found, permission denied), and programmer errors (bugs in the code)."
,99. How can you use logging to aid in error diagnostics?,"Logging is crucial for diagnostics. You should log detailed error information, including the error message, stack trace, timestamp, and relevant context (like request IDs or user info). Using structured logging (e.g., JSON format) and different log levels (error, warn, info) makes logs easier to parse and analyze."
,100. Explain how to use try...catch with JSON.parse().,"JSON.parse() is synchronous and will throw a SyntaxError if the string it's trying to parse is not valid JSON. To handle this, you must wrap the JSON.parse() call in a try...catch block."
V. Streams and Buffers,101. What are streams in Node.js?,"Streams are objects in Node.js that let you read data from a source or write data to a destination in a continuous fashion. Instead of reading an entire file into memory at once, streams allow you to process data in small, manageable chunks."
,102. What are the benefits of using streams?,"The main benefits are: Memory efficiency, as you don't need to load large amounts of data into memory, and Time efficiency, as you can start processing data as soon as the first chunk arrives, rather than waiting for the entire payload to be available."
,103. Name the four types of streams in Node.js.,"1. Readable: Streams from which data can be read (e.g., fs.createReadStream). 2. Writable: Streams to which data can be written (e.g., fs.createWriteStream). 3. Duplex: Streams that are both Readable and Writable (e.g., a TCP socket). 4. Transform: Duplex streams that can modify or transform the data as it is written and read (e.g., a zlib compression stream)."
,104. What is a Readable stream? Give an example.,A Readable stream is an abstraction for a source from which data is consumed. An example is reading a file from the file system: fs.createReadStream('file.txt').
,105. What is a Writable stream? Give an example.,A Writable stream is an abstraction for a destination to which data is written. An example is writing data to a file: fs.createWriteStream('file.txt').
,106. What is a Duplex stream?,"A Duplex stream is a stream that implements both the Readable and Writable interfaces. Examples include a TCP socket, a zlib stream, or a crypto stream."
,107. What is a Transform stream?,"A Transform stream is a type of Duplex stream where the output is computed in some way from the input. It reads input, ""transforms"" it, and then produces output. Examples include zlib for compression/decompression or a custom stream to convert text to uppercase."
,108. What is piping in Node.js?,"Piping is a mechanism for connecting the output of a Readable stream to the input of a Writable stream. It's done using the .pipe() method. Piping automatically handles the flow of data, including backpressure, making it a very efficient way to process data. Example: readableStream.pipe(writableStream)."
,109. How do you create a Readable stream?,"You can create a custom Readable stream by extending the stream.Readable class and implementing the _read() method. Inside _read(), you use this.push() to push data into the stream's internal buffer."
,110. How do you create a Writable stream?,You can create a custom Writable stream by extending the stream.Writable class and implementing the _write() method. This method receives the chunk of data to be written.
,111. What is a Buffer?,A Buffer is a Node.js class that is used to handle raw binary data. It corresponds to a raw memory allocation outside the V8 heap. Buffers are used because JavaScript traditionally hasn't handled binary data well.
,112. Why are Buffers necessary in Node.js?,"Buffers are necessary to interact with octet streams in TCP streams, file system operations, and other contexts. They allow Node.js to work with binary data directly and efficiently."
,113. How do you create a Buffer?,"Buffers can be created in several ways, but the most common modern methods are Buffer.from(string[, encoding]) to create a buffer from a string, and Buffer.alloc(size) to create a new, zero-filled buffer of a specified size."
,114. How do you convert a Buffer to a string?,"You can convert a Buffer to a string by calling the .toString([encoding]) method on the buffer instance. For example, buf.toString('utf8')."
,115. How do you convert a string to a Buffer?,"You can convert a string to a Buffer using the Buffer.from(string, [encoding]) method. For example, Buffer.from('hello', 'utf8')."
,116. Explain the difference between a stream's flowing and paused modes.,A Readable stream can be in one of two modes: Flowing: Data is read from the underlying system automatically and provided to your application as fast as possible. This happens when you attach a data event handler or use .pipe(). Paused: You must explicitly call stream.read() to get chunks of data out of the stream. All streams start in paused mode.
,117. What is backpressure in streams and how is it handled?,"Backpressure is a mechanism that handles data flow when the Writable stream is slower than the Readable stream. The .pipe() method handles this automatically. When a Writable stream's internal buffer is full, its .write() method will return false. This signals the Readable stream to stop sending data until the Writable stream emits a drain event, indicating it's ready for more."
,118. What is the stream.pipeline() method and why is it useful?,"stream.pipeline() is a method for piping between streams that provides better error handling. It forwards errors and properly cleans up all the streams when any one of them is closed or errors. It's a safer alternative to .pipe(), which can lead to memory leaks if not handled carefully on error."
,119. Explain the finish and end events in streams.,The finish event is emitted by a Writable stream when stream.end() has been called and all data has been flushed to the underlying system. The end event is emitted by a Readable stream when there is no more data to be consumed from the stream.
,120. How do you handle errors in streams?,"Errors in streams are handled by listening for the error event. It is crucial to always have an error event listener on a stream, as an unhandled error event will cause the Node.js process to crash. When using stream.pipeline(), you can provide a callback function that will be called with an error if one occurs."
,121. What is the object mode in streams?,"By default, streams operate on strings and Buffers. By setting the objectMode: true option, you can make a stream accept any JavaScript object. This is useful when you want to pass structured data through a stream pipeline."
,122. How would you implement a custom Transform stream?,"You implement a custom Transform stream by extending the stream.Transform class and implementing the _transform() method. This method receives the data chunk, its encoding, and a callback. You can perform operations on the chunk and then use this.push() to pass the modified data to the next stream in the chain."
,123. What are some real-world use cases for streams?,"Reading/writing large files, processing large HTTP request/response bodies, data compression/decompression (e.g., gzipping files), real-time data processing (e.g., from WebSockets), and ETL (Extract, Transform, Load) pipelines."
,124. How do streams relate to the event loop?,"Streams are built on top of Node.js's event-driven architecture. I/O operations for streams are non-blocking. When a chunk of data is available (data event) or a stream is ready for more data (drain event), these events are placed on the event loop to be processed."
,125. Explain the drain event in a Writable stream.,The drain event is emitted by a Writable stream when it is ready to accept more data. This happens after its internal buffer has been emptied following a write() call that returned false. It is a signal for the data producer to resume writing.
,126. How can you combine multiple streams into one?,"You can use stream.pipeline() to chain multiple streams together in a safe way. For more complex scenarios, you can use libraries like through2 or manually pipe streams together (stream1.pipe(stream2).pipe(stream3)), ensuring you handle errors correctly on each stream."
,"127. What is the difference between Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()?","Buffer.from(data): Creates a buffer from existing data (like a string, array, or another buffer). Buffer.alloc(size): Creates a new, ""safe"" buffer of a specified size. The memory is pre-filled with zeros, which prevents old, sensitive data from being leaked. Buffer.allocUnsafe(size): Creates a new, uninitialized buffer. It is faster than Buffer.alloc() but may contain old data from memory. It must be filled with new data immediately to be used safely."
VI. Child Processes,128. What are child processes in Node.js?,"Child processes are new processes that can be spawned from a main Node.js application. This allows you to execute external commands or run other scripts, leveraging multiple CPU cores and avoiding blocking the main event loop with CPU-intensive tasks."
,129. Why would you use child processes?,"To run CPU-intensive tasks without blocking the main event loop, to execute external system commands or utilities (like git or ls), and to take advantage of multi-core systems for better performance."
,130. What is the child_process module?,The child_process module is a core Node.js module that provides the functionality to create and manage child processes.
,131. What are the four different ways to create a child process in Node.js?,"The four methods are: spawn(), exec(), execFile(), and fork()."
,"132. Explain the difference between spawn(), fork(), exec(), and execFile().","spawn(): Spawns a new process and streams I/O. Best for long-running processes or when the command produces a large amount of data. exec(): Spawns a shell and runs a command in that shell. It buffers the output and passes it to a callback when the process is done. Good for quick commands. execFile(): Similar to exec() but runs an executable file directly without spawning a shell, which is slightly more efficient and secure. fork(): A special version of spawn() for creating a new Node.js process. It creates a communication channel (IPC) between the parent and child, allowing them to send messages."
,133. When would you use spawn() vs. exec()?,"Use spawn() when you need to handle streaming data from the child process, for example, when processing a large file or a continuous data stream. Use exec() for short, simple commands where you just need the final buffered output."
,134. What is the difference between fork() and spawn()?,"fork() is a specialized version of spawn() specifically for creating new Node.js processes. The key difference is that fork() automatically sets up an IPC (Inter-Process Communication) channel, allowing messages to be passed between the parent and child processes using .send() and .on('message')."
,135. How can parent and child processes communicate with each other?,"When using fork(), the parent and child can communicate using the built-in IPC channel. The parent can call child.send(message) and the child can call process.send(message). Both can listen for messages using the message event: child.on('message', ...) and process.on('message', ...)."
,136. What is the ipc channel?,The IPC (Inter-Process Communication) channel is a communication pipeline established between a parent process and a child process created using child_process.fork(). It allows for the exchange of JSON messages between the two processes.
,137. How can you pass data from a parent to a forked child process?,"You can pass data from the parent to the forked child by calling the send() method on the child process object: child.send({ hello: 'world' }). The child process can then listen for this data using process.on('message', (msg) => { ... });."
,138. How do you handle errors in child processes?,"You can listen for the error event on the child process object, which is emitted if the process could not be spawned or killed. You can also listen for non-zero exit codes via the exit or close events, and monitor stderr for any error output from the command itself."
,139. What is a detached child process?,A detached child process is a process that can continue running independently even after its parent process exits. You can create one by setting the detached: true option in spawn() or fork().
VII. Clustering and Scaling,140. What is the cluster module?,"The cluster module is a core Node.js module that allows you to create a cluster of Node.js processes. This enables a single Node.js application to take advantage of multi-core systems by running multiple instances of the application, known as workers."
,141. How does the cluster module work?,The cluster module works by creating a master process that forks several worker processes. The master process does not handle application logic itself but manages the workers. It listens on a port and distributes incoming connections to the worker processes.
,142. What are the benefits of using the cluster module?,"The primary benefit is improved performance and reliability on multi-core systems. It allows a Node.js application to handle more concurrent requests by distributing the load across multiple CPU cores. It also improves fault tolerance, as the master process can restart a worker if it crashes."
,143. How do you create a cluster in Node.js?,"You create a cluster by checking if the current process is the master (cluster.isMaster or cluster.isPrimary in newer versions). If it is, you fork worker processes using cluster.fork(). If it's a worker process, you run the application logic (e.g., start the HTTP server)."
,144. What is the difference between the master process and worker processes?,"The master process is responsible for creating, managing, and monitoring the worker processes. It binds to a network port and distributes incoming connections. The worker processes are the ones that actually run the application code, handle client requests, and do the work."
,145. How does the master process distribute incoming connections to worker processes?,"By default, the master process listens on a port and distributes incoming connections to the worker processes using a round-robin algorithm. This helps to balance the load across all available workers."
,146. How can you achieve zero-downtime restarts with the cluster module?,"You can achieve zero-downtime restarts by restarting workers one by one. When you need to update the application, you instruct the master to kill an old worker and then fork a new one with the updated code. This process is repeated for each worker, ensuring there are always active workers available to handle requests."
,147. What are some strategies for scaling a Node.js application?,"Strategies include: 1. Clustering: Using the cluster module to scale across multiple CPU cores on a single machine. 2. Horizontal Scaling: Adding more machines (servers) and distributing traffic between them using a load balancer. 3. Microservices: Breaking down the application into smaller, independent services that can be scaled individually. 4. Caching: Using caching layers (like Redis) to reduce the load on the application and database."
,148. Explain horizontal vs. vertical scaling.,"Vertical Scaling (scaling up) means adding more resources (CPU, RAM) to a single server to make it more powerful. Horizontal Scaling (scaling out) means adding more servers to your pool of resources and distributing the load among them. Node.js applications, due to their stateless nature, are well-suited for horizontal scaling."
,149. What is a reverse proxy and how is it used with Node.js?,"A reverse proxy is a server that sits in front of one or more web servers (like a Node.js application) and forwards client requests to them. It's commonly used with Node.js to handle tasks like load balancing across multiple Node.js instances, SSL termination, caching static content, and providing a single point of entry for security. Nginx and HAProxy are popular examples."
,150. How can you use a process manager like PM2 to scale a Node.js application?,"A process manager like PM2 simplifies scaling. You can start an application in ""cluster mode"" using a single command (e.g., pm2 start app.js -i max), and PM2 will automatically use the cluster module to spawn a worker for each available CPU core. It also provides features like monitoring, automatic restarts, and zero-downtime reloads."
VIII. Express.js,151. What is Express.js?,"Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for building web and mobile applications. It simplifies the process of creating servers, handling requests, and defining routes."
,152. Why is Express.js a popular framework for Node.js?,"It's popular because it's fast, unopinionated, and minimalist. It provides a thin layer of fundamental web application features without obscuring Node.js features. Its powerful routing system and middleware architecture make it highly extensible and easy to use."
,153. How do you create a simple Express application?,"You require('express'), create an app instance with const app = express(), define a route (e.g., app.get('/', (req, res) => { ... })), and then make the app listen on a port with app.listen(port, () => { ... })."
,154. What is routing in Express?,"Routing refers to how an application's endpoints (URIs) respond to client requests. It involves defining routes that match specific HTTP methods (GET, POST, etc.) and URL patterns."
,155. How do you define a route in Express?,"You define a route using methods on the app object that correspond to HTTP verbs, like app.get(), app.post(), etc. The method takes a path as the first argument and a callback function (the route handler) as the second."
,156. What are route parameters?,"Route parameters are named URL segments used to capture values at specific positions in the URL. They are prefixed with a colon (:). For a route like /users/:userId, the userId can be accessed via req.params.userId."
,157. How do you handle GET and POST requests in Express?,"You use app.get('/path', handler) for GET requests and app.post('/path', handler) for POST requests. The handler function receives req and res objects to process the request and send a response."
,158. What is middleware in Express?,"Middleware functions are functions that have access to the request object (req), the response object (res), and the next function in the application's request-response cycle. They can execute code, make changes to the request and response objects, end the request-response cycle, or call the next middleware in the stack."
,159. What are the req and res objects in Express?,"req (request) is an object containing information about the incoming HTTP request, such as headers, parameters, body, and URL. res (response) is an object used to send an HTTP response back to the client, for example, by setting headers and sending data."
,160. What is the next() function in middleware?,"The next() function is a function in the Express router which, when invoked, executes the next middleware in the stack. If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function."
,161. What are the different types of middleware?,"Types include: Application-level middleware (bound to app.use() or app.METHOD()), Router-level middleware (bound to an instance of express.Router()), Error-handling middleware (has four arguments: (err, req, res, next)), Built-in middleware (like express.json(), express.static()), and Third-party middleware (installed via npm, e.g., cors, helmet)."
,162. How do you serve static files in Express?,"You use the built-in express.static middleware. For example, app.use(express.static('public')) will serve files from the public directory. If you place an index.html file in public, it will be served for the root URL."
,163. How do you render templates in Express?,"You first set a template engine (e.g., EJS or Pug) using app.set('view engine', 'ejs'). Then, in a route handler, you use the res.render() method, passing the name of the view file and an object with data to be rendered."
,164. What is the purpose of app.use()?,"app.use() is used to mount middleware functions at a specified path. If no path is specified, the middleware is executed for every request to the app. It's used for tasks that apply globally, like logging, parsing request bodies, or serving static files."
,165. Explain the order of middleware execution in Express.,"Middleware functions are executed sequentially in the order they are defined in your code. The order is crucial, as a middleware defined earlier can prevent later middleware from running if it ends the request-response cycle."
,166. How do you create custom middleware?,"You create a function that accepts req, res, and next as arguments. Inside the function, you perform your desired logic and then call next() to pass control to the next middleware, unless you are sending a response to end the cycle."
,167. What is error-handling middleware in Express?,"Error-handling middleware is a special type of middleware defined with four arguments: (err, req, res, next). It must be defined after all other app.use() and routes calls. It's used to catch and process errors that occur in your application."
,168. How do you use a router to organize your routes?,"You can use express.Router() to create modular, mountable route handlers. You can define routes on the router object, apply middleware to it, and then mount the router on a path in your main application file using app.use('/path', router). This helps keep your route-related code organized."
,169. What is the difference between app.use() and app.get()?,"app.get('/path', ...) only handles GET requests to the exact specified path. app.use('/path', ...) handles all HTTP methods (GET, POST, etc.) for any path that begins with /path. app.use() is for mounting middleware, while app.get() is for defining a specific route handler."
,170. How can you get query parameters from a URL in Express?,"Query parameters (the part of the URL after ?) are available in the req.query object. For a URL like /search?q=nodejs, req.query.q would be ""nodejs""."
,171. How do you handle form data in Express?,"To handle URL-encoded form data (from a standard HTML form submission), you use the express.urlencoded({ extended: true }) middleware. To handle JSON data, you use the express.json() middleware. The parsed data will be available on req.body."
,"172. Explain the purpose of req.params, req.query, and req.body.","req.params: An object containing route parameters. For /users/:id, the id is in req.params. req.query: An object containing the URL query string parameters. For /search?q=hello, the query is in req.query. req.body: An object containing the parsed request body, typically from POST or PUT requests. Requires middleware like express.json() to be populated."
,173. What is the purpose of the express.json() and express.urlencoded() middleware?,express.json() is a built-in middleware that parses incoming requests with JSON payloads. express.urlencoded() is a built-in middleware that parses incoming requests with URL-encoded payloads (often from HTML forms). Both populate the req.body object.
,174. How do you set response headers in Express?,"You can use the res.set('Header-Name', 'Header-Value') method or res.header('Header-Name', 'Header-Value'). You can also chain them. Methods like res.json() or res.send() often set headers like Content-Type automatically."
,"175. What is the difference between res.send(), res.json(), and res.end()?","res.send(body): A versatile method that can send various types of responses (string, buffer, object, array). It sets the Content-Type header appropriately and ends the response. res.json(body): Sends a JSON response. It converts the object/array to a JSON string and sets the Content-Type header to application/json. res.end(): Ends the response process without sending any data. It's used when no response body is needed."
,176. How do you handle cookies and sessions in Express?,"Cookies are handled using third-party middleware like cookie-parser. Sessions are typically handled with middleware like express-session, which uses cookies to store a session ID and keeps session data on the server side (in memory, a database, or a cache like Redis)."
,177. How can you secure an Express application?,Use middleware like helmet to set various security-related HTTP headers. Sanitize and validate user input to prevent injection attacks. Use HTTPS. Implement proper authentication and authorization. Manage dependencies and audit for vulnerabilities with npm audit.
,178. What is the purpose of a template engine like EJS or Pug?,"A template engine allows you to use static template files in your application. At runtime, the template engine replaces variables in a template file with actual values and transforms the template into an HTML file sent to the client. This allows for dynamic generation of web pages."
IX. Databases,179. How do you connect a Node.js application to a database like MongoDB or PostgreSQL?,"You use a database driver or library specific to that database. For MongoDB, you'd use the mongodb driver or an ODM like Mongoose. For PostgreSQL, you'd use the pg driver or an ORM like Sequelize. You typically provide a connection string with credentials to the library's connect method."
,180. What is an ODM (Object-Document Mapper) and an ORM (Object-Relational Mapper)?,An ODM maps data between objects in your application code and documents in a NoSQL database like MongoDB. An ORM maps data between objects and tables in a relational database (SQL) like PostgreSQL. Both provide a higher-level abstraction for interacting with the database.
,181. What is Mongoose and why is it used with MongoDB?,"Mongoose is an elegant ODM for MongoDB and Node.js. It's used because it provides schema validation, casting, query building, middleware (hooks), and business logic hooks, which makes managing data and interacting with MongoDB easier and more structured than using the native driver alone."
,182. How do you define a schema and model in Mongoose?,"A Schema is defined using new mongoose.Schema({ ... }). It defines the structure of the documents, default values, and validators. A Model is a constructor compiled from a Schema definition. An instance of a model represents a document that can be saved to the database. It's created with mongoose.model('ModelName', schema)."
,"183. How do you perform CRUD (Create, Read, Update, Delete) operations with Mongoose?","Create: const doc = new Model(data); await doc.save(); or Model.create(data). Read: Model.find({}), Model.findOne({_id: ...}), Model.findById(...). Update: Model.updateOne({_id: ...}, { $set: { ... } }), Model.findByIdAndUpdate(...). Delete: Model.deleteOne({_id: ...}), Model.findByIdAndRemove(...)."
,184. What is Sequelize and what is it used for?,"Sequelize is a popular Promise-based Node.js ORM for relational databases like PostgreSQL, MySQL, MariaDB, SQLite, and Microsoft SQL Server. It is used to simplify database interactions by allowing developers to work with JavaScript objects instead of writing raw SQL queries."
,185. Explain how to perform a query using Sequelize.,"After defining a model (which maps to a table), you can use model methods to perform queries. For example: User.findAll(), User.findOne({ where: { name: 'John' } }), User.create({ name: 'Jane' }), User.update({ status: 'active' }, { where: { id: 1 } }), User.destroy({ where: { id: 1 } })."
,186. What is connection pooling and why is it important?,Connection pooling is the practice of creating and maintaining a cache of database connections that can be reused for future requests. It is important because establishing a new database connection for every request is a slow and resource-intensive process. Pooling significantly improves application performance and scalability.
,187. How do you handle database connection errors?,"You should listen for error events on the connection object provided by the database driver. It's also crucial to implement a retry mechanism with exponential backoff for initial connection failures. For errors during a query, you should use try...catch blocks with async/await or .catch() with Promises."
,188. What are database transactions and how do you implement them in Node.js?,"A transaction is a sequence of operations performed as a single logical unit of work. All operations must succeed; otherwise, the entire transaction is rolled back. In Node.js, libraries like Sequelize and Mongoose provide session/transaction management methods (e.g., sequelize.transaction(), mongoose.startSession())."
,189. How can you prevent SQL injection attacks?,"Use an ORM/ODM like Sequelize or Mongoose, which automatically sanitizes inputs. If writing raw SQL, always use parameterized queries (prepared statements) instead of concatenating user input directly into query strings. This ensures that user input is treated as data, not as executable code."
,190. What are some best practices for interacting with databases in a Node.js application?,"Use connection pooling. Separate database logic from business logic (e.g., using a repository pattern). Sanitize all user input to prevent injection attacks. Use an ORM/ODM to abstract database interactions. Add indexes to frequently queried fields. Close database connections gracefully when the application shuts down."
X. Testing,191. Why is testing important for Node.js applications?,"Testing is important to ensure code correctness, prevent regressions (bugs in existing features), facilitate refactoring, and document the behavior of the application. It increases confidence in the stability and quality of the codebase."
,"192. What are the different types of testing (unit, integration, end-to-end)?","Unit Testing: Tests individual functions or components in isolation. Integration Testing: Tests how multiple components work together. End-to-End (E2E) Testing: Tests the entire application flow from the user's perspective, simulating real user scenarios."
,"193. What are some popular testing frameworks for Node.js? (e.g., Mocha, Jest, Chai)","Jest: A popular, all-in-one testing framework developed by Facebook. It includes a test runner, assertion library, and mocking capabilities. Mocha: A flexible and feature-rich test framework that provides a test runner. It's often paired with an assertion library like Chai. Chai: An assertion library that provides expressive and readable syntax for checking test outcomes (e.g., expect(foo).to.be.a('string'))."
,194. What is the purpose of an assertion library like Chai?,"An assertion library provides functions to verify that test outcomes are correct. It allows you to write claims about your code's behavior (e.g., ""I expect this variable to equal 5""). If an assertion fails, it throws an error, causing the test to fail."
,195. How do you write a simple unit test for a function?,"You import the function to be tested, describe the test suite using describe(), define a specific test case using it() or test(), call the function with sample input, and then use an assertion library to check if the function's actual output matches the expected output."
,196. What is a test runner?,"A test runner is a tool that finds and executes your test files, and then reports the results. Frameworks like Jest and Mocha are test runners. They provide the structure (describe, it) and the command-line interface to run the tests."
,197. How do you test asynchronous code?,"Testing frameworks provide mechanisms for async code. With callbacks, you use a done argument and call it when the async operation is complete. With Promises, you return the promise from the test function. With async/await, you simply declare the test function as async and use await inside it."
,"198. What are mocks, stubs, and spies?","Mocks: Objects that mimic the behavior of real objects in controlled ways. Stubs: Functions that replace existing functions and return predefined values. Used to control the behavior of dependencies. Spies: Functions that wrap existing functions to record information, such as how many times they were called and with what arguments, without changing the original function's behavior."
,199. What is Sinon.JS and what is it used for?,"Sinon.JS is a popular standalone library for creating spies, stubs, and mocks in JavaScript. It is framework-agnostic and is often used alongside test runners like Mocha to test interactions and control dependencies."
,200. How do you test an Express API endpoint?,"You use a library like supertest, which allows you to make HTTP requests to your Express app without needing to run it on a live server. You can then make assertions about the response status code, headers, and body."
,201. What is code coverage and why is it useful?,"Code coverage is a metric that measures the percentage of your codebase that is executed during your automated tests. It is useful for identifying untested parts of your application, but a high percentage does not guarantee the quality of the tests themselves."
,202. What are some tools for measuring code coverage?,"Jest has built-in code coverage support using istanbul. For other frameworks like Mocha, you can use tools like nyc (the command-line interface for istanbul) to generate coverage reports."
,203. What is Test-Driven Development (TDD)?,TDD is a software development process where you write a failing test case before you write the production code to make it pass. The cycle is: 1. Red: Write a test that fails. 2. Green: Write the minimal code needed to make the test pass. 3. Refactor: Improve the code without changing its behavior.
,204. What is Behavior-Driven Development (BDD)?,"BDD is an extension of TDD that focuses on describing the application's behavior from the user's perspective. It uses a natural language syntax (e.g., ""Given-When-Then"") to define test cases, which makes tests more understandable to non-technical stakeholders. Mocha and Chai's BDD syntax (describe, it, expect) are examples of BDD-style testing."
XI. Security,205. What are some common security vulnerabilities in Node.js applications?,"Common vulnerabilities include Cross-Site Scripting (XSS), SQL/NoSQL Injection, Cross-Site Request Forgery (CSRF), insecure direct object references, security misconfigurations, and using components with known vulnerabilities."
,206. How can you prevent Cross-Site Scripting (XSS) attacks?,"Prevent XSS by validating and sanitizing all user input and by encoding output displayed on a page. Libraries like helmet can set security headers (e.g., Content-Security-Policy) to mitigate XSS risks."
,207. How can you prevent Cross-Site Request Forgery (CSRF) attacks?,"CSRF is prevented by using anti-CSRF tokens. A unique, secret token is generated for each user session and embedded in forms. The server validates this token on subsequent requests to ensure they are legitimate. Libraries like csurf can be used in Express."
,208. What is a CSRF token?,"A CSRF token is a unique, secret, and unpredictable value that a server-side application generates and sends to the client. The client includes this token with every subsequent state-changing request. The server validates the token to ensure the request came from the original application, not a malicious site."
,209. How can you prevent NoSQL injection attacks?,Avoid building queries by concatenating strings with user input. Use an ODM like Mongoose which has built-in protection. Sanitize and validate user-supplied data to ensure it conforms to the expected schema and type.
,210. What is authentication vs. authorization?,"Authentication is the process of verifying who a user is (e.g., with a username and password). Authorization is the process of determining what an authenticated user is allowed to do (e.g., granting admin access). Authentication comes before authorization."
,211. How do you implement authentication in a Node.js application?,"Authentication is typically implemented using either session-based authentication (where a session ID is stored in a cookie) or token-based authentication (like JSON Web Tokens), often with the help of libraries like Passport.js. Password hashing with libraries like bcrypt is crucial."
,212. What are JSON Web Tokens (JWT) and how do they work?,"JWTs are compact, self-contained tokens for securely transmitting information between parties as a JSON object. The server generates a JWT upon successful login, signs it with a secret key, and sends it to the client. The client then includes this JWT in the header of subsequent requests. The server can verify the token's signature to authenticate the request without needing to access a database."
,213. What are the components of a JWT?,"A JWT consists of three parts separated by dots (.): 1. Header: Contains the token type (JWT) and the signing algorithm used. 2. Payload: Contains the claims (data) about the user, like user ID and expiration time. 3. Signature: A cryptographic signature created using the encoded header, encoded payload, and a secret key."
,214. How do you securely store passwords in a database?,"Passwords should never be stored in plain text. They must be hashed using a strong, slow, and salted hashing algorithm. Salting involves adding a random string to each password before hashing to ensure that identical passwords have different hashes."
,215. What is bcrypt?,"bcrypt is a popular and highly secure password-hashing function. It is designed to be slow, which makes it resistant to brute-force attacks. It automatically handles the generation and inclusion of a salt within the final hash string."
,216. What is the purpose of the helmet middleware in Express?,"helmet is a collection of 15 smaller middleware functions that set various HTTP headers to help secure your Express application. It helps protect against common attacks like XSS, clickjacking, and other well-known vulnerabilities by configuring headers like Content-Security-Policy and X-Frame-Options."
,217. How can you prevent insecure direct object references?,"Prevent this by implementing proper authorization checks. Before allowing access to a resource (like a user profile or document), verify that the currently authenticated user has the permission to access that specific resource, instead of just relying on the ID provided by the client."
,218. What is rate limiting and how can you implement it?,"Rate limiting restricts how many times a user can perform an action in a given time frame (e.g., limiting login attempts). It helps prevent brute-force attacks and DoS attacks. In Node.js, it can be implemented using middleware like express-rate-limit or by using a tool like Redis."
,219. Why is it important to keep your dependencies up to date?,Dependencies can have security vulnerabilities that attackers can exploit. Keeping them up to date ensures you have the latest security patches. It's a critical part of application security maintenance.
,220. What is npm audit?,"npm audit is a command that scans your project's dependencies for known security vulnerabilities. It provides a report of the vulnerabilities found and, in many cases, can automatically fix them by updating packages to a secure version with npm audit fix."
XII. Performance and Optimization,221. How can you profile a Node.js application to identify performance bottlenecks?,"You can use Node.js's built-in profiler (node --prof), which generates a tick file that can be processed to identify CPU-intensive functions. Tools like Chrome DevTools can also be connected to a running Node.js process for profiling CPU and memory usage."
,222. What are some tools for profiling Node.js applications?,"Built-in Profiler: node --prof. Chrome DevTools: Connects to the Node.js inspector. Clinic.js: A suite of tools (Doctor, Bubbleprof, Flame) that helps diagnose performance issues. External APM tools: New Relic, Datadog, Dynatrace."
,223. How can you identify and fix memory leaks in a Node.js application?,"Memory leaks can be identified by taking heap snapshots of the application at different times and comparing them to see which objects are growing in number without being garbage collected. Tools like Chrome DevTools are excellent for taking and analyzing heap snapshots. Fixing them involves finding the code that is unintentionally holding references to objects, preventing them from being collected."
,224. What are heap snapshots and how can they be used to debug memory issues?,"A heap snapshot is a ""photograph"" of the memory heap at a specific point in time, showing all objects and their references. By comparing two snapshots, you can identify objects that were allocated but not released, which points to a potential memory leak."
,225. Explain how to use the clinic.js suite of tools.,"Clinic.js is used to diagnose performance issues. You run your app via one of its tools (e.g., clinic doctor -- node server.js). clinic doctor detects the type of issue (I/O, CPU, memory). clinic bubbleprof visualizes async operations. clinic flame creates flame graphs to pinpoint CPU bottlenecks."
,226. How can you optimize CPU-bound tasks in a single-threaded Node.js application?,"Since CPU-bound tasks block the event loop, they should be moved out of the main thread. This can be done using worker threads, the child_process module to spawn a separate process, or by offloading the task to a dedicated background job queue system."
,227. What are worker threads and when should you use them?,"The worker_threads module allows you to run JavaScript code in parallel on separate threads. You should use them for CPU-intensive tasks like complex calculations, image processing, or cryptography, as they prevent blocking the main event loop. They are not ideal for I/O-bound work, as Node.js's native async I/O is more efficient for that."
,228. How do worker threads differ from the cluster module?,"Cluster is for creating multiple processes to handle I/O-bound workloads (like an HTTP server), where each process has its own event loop and memory. Worker threads are for running CPU-bound code in parallel within a single process, sharing memory through mechanisms like SharedArrayBuffer."
,229. What is caching and what are some common caching strategies?,"Caching is the process of storing copies of data in a temporary storage location (a cache) so that future requests for that data can be served faster. Common strategies include in-memory caching, distributed caching (e.g., Redis, Memcached), and client-side (browser) caching."
,"230. How can you implement caching in a Node.js application (e.g., using Redis)?","You can use an in-memory cache with a simple JavaScript Map or a library like node-cache. For a distributed cache, you would use a client library like redis or ioredis to connect to a Redis server. Before making an expensive call (e.g., to a database), you check if the result is in the cache. If so, you return the cached data; otherwise, you perform the operation and store the result in the cache for next time."
,231. How can you optimize database queries?,"Optimization techniques include: adding indexes to frequently queried fields, selecting only the columns you need (SELECT col1, col2 instead of SELECT *), using database connection pooling, analyzing query performance with tools like EXPLAIN, and caching frequent query results."
,232. What is latency and how can you reduce it in a Node.js application?,"Latency is the time delay between a cause and effect. In networking, it's the time it takes for a data packet to travel from one point to another. You can reduce it by using a Content Delivery Network (CDN) to serve assets closer to users, optimizing database queries, using caching, and scaling your application horizontally to handle more load."
,"233. How does garbage collection work in V8, and how can it impact performance?","V8's garbage collector (GC) reclaims memory used by objects that are no longer needed. It uses a generational approach with two main phases: a fast ""scavenge"" for the ""young generation"" (new objects) and a slower ""mark-sweep-compact"" for the ""old generation"" (long-surviving objects). GC can cause performance issues because it pauses JavaScript execution (""stop-the-world"" events), which can lead to noticeable delays or ""jank."""
,234. What is code JIT-compilation in V8?,"Just-In-Time (JIT) compilation is a technique used by V8 to improve performance. It starts by interpreting JavaScript code, but if a piece of code is executed frequently (""hot""), V8 compiles it into highly optimized machine code at runtime. This makes subsequent executions of that code much faster."
,235. How can you optimize the startup time of a Node.js application?,Minimize the number of dependencies loaded on startup. Use lazy loading for modules that are not immediately needed. Consider using module bundlers for backend applications in some cases to reduce file I/O. Avoid performing long synchronous operations in the main module.
,236. What is the impact of large JSON payloads on performance?,"Parsing large JSON payloads using JSON.parse() is a synchronous and CPU-intensive operation that can block the event loop, making the application unresponsive. It's better to stream and process large JSON files if possible using libraries like JSONStream."
,237. How can you use load balancing to improve performance?,"A load balancer distributes incoming network traffic across multiple servers (or Node.js processes). This improves performance by preventing any single server from becoming a bottleneck, increasing application capacity, and improving reliability."
,238. What is the event loop lag and how can you monitor it?,"Event loop lag is the delay between when a task is scheduled to run (e.g., with setTimeout) and when it actually executes. It's a key indicator of how ""busy"" the event loop is. A high lag means the loop is being blocked by long-running synchronous code. You can monitor it using libraries like event-loop-lag or APM tools."
,239. How can you benchmark your Node.js application?,"You can use command-line tools like autocannon or wrk to send a high volume of HTTP requests to your application and measure its performance (requests/sec, latency). For specific functions, you can use libraries like benchmark.js."
,240. What are some best practices for writing performant Node.js code?,"Embrace asynchronicity for all I/O operations. Avoid synchronous, blocking calls in the main thread. Use streams for large data sets. Use caching where appropriate. Optimize database queries. Offload CPU-intensive tasks to worker threads. Use a process manager like PM2 in cluster mode."
XIII. Architectural Patterns,241. What is a monolithic architecture? What are its pros and cons?,"A monolithic architecture is one where the entire application is built as a single, tightly coupled unit. Pros: Simple to develop, test, and deploy initially. Cons: Becomes difficult to scale, maintain, and update as it grows. A bug in one module can bring down the entire application."
,242. What is a microservices architecture? What are its pros and cons?,"A microservices architecture structures an application as a collection of small, independent, and loosely coupled services. Pros: Services can be developed, deployed, and scaled independently. Improved fault isolation. Technology flexibility. Cons: Increased complexity in deployment, monitoring, and managing communication between services."
,243. How would you design a RESTful API?,"I would design it by defining resources (e.g., users, products), using nouns in URLs (e.g., /users, /products/:id), using HTTP methods correctly (GET, POST, PUT, DELETE), using HTTP status codes to indicate outcomes (200, 201, 404, 500), and using JSON as the data format. Versioning (e.g., /api/v1/...) is also important."
,244. What are the principles of REST?,REST (REpresentational State Transfer) is an architectural style with key constraints: 1. Client-Server: Separation of concerns. 2. Stateless: Each request from a client must contain all the information needed to understand and complete the request. 3. Cacheable: Responses must define themselves as cacheable or not. 4. Layered System: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary. 5. Uniform Interface: A common interface between client and server simplifies and decouples the architecture.
,245. What is GraphQL and how does it differ from REST?,"GraphQL is a query language for APIs and a runtime for fulfilling those queries. The main difference is that with GraphQL, the client specifies exactly what data it needs, and the server returns only that data in a single request. With REST, the server defines the structure of the response, often leading to over-fetching (getting more data than needed) or under-fetching (requiring multiple requests)."
,246. What are the benefits of using GraphQL?,"Benefits include: no over-fetching or under-fetching, a single endpoint for all queries, a strongly typed schema that serves as documentation, and the ability for clients to evolve without requiring server-side changes."
,247. What is a serverless architecture?,"Serverless architecture (or Function-as-a-Service, FaaS) is a cloud computing model where the cloud provider manages the server infrastructure and automatically allocates resources. You write and deploy code in the form of functions, which are executed in response to events. You only pay for the execution time."
,"248. What are some popular serverless platforms for Node.js (e.g., AWS Lambda, Google Cloud Functions)?","Popular serverless platforms for Node.js include AWS Lambda, Google Cloud Functions, Azure Functions, and Vercel."
,249. What is the Model-View-Controller (MVC) pattern?,"MVC is an architectural pattern that separates an application into three interconnected components: Model (manages data and business logic), View (handles the presentation and user interface), and Controller (receives user input and orchestrates interactions between the Model and the View)."
,250. How can you implement the MVC pattern in a Node.js application?,"In a typical Express application: Model: Mongoose or Sequelize schemas and models that interact with the database. View: Template files (e.g., EJS, Pug) that render the UI. Controller: Express route handlers that process incoming requests, interact with the model, and render the appropriate view."
,251. What is the publish-subscribe pattern?,"The publish-subscribe (pub/sub) pattern is a messaging pattern where senders of messages (publishers) do not program the messages to be sent directly to specific receivers (subscribers). Instead, messages are published to channels or topics, and subscribers receive messages for the topics they are subscribed to."
,252. How can you implement the publish-subscribe pattern in Node.js?,"You can implement it using Node.js's built-in EventEmitter class for in-process communication. For distributed systems, you would use a dedicated message broker like Redis (using its PUB/SUB feature), RabbitMQ, or Kafka."
,253. What is the factory pattern?,"The factory pattern is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created. It's used when you want to create objects without exposing the creation logic to the client."
,254. What is the singleton pattern?,"The singleton pattern is a design pattern that restricts the instantiation of a class to a single object. This is useful when exactly one object is needed to coordinate actions across the system (e.g., a database connection object or a logger). Node.js modules are singletons by default due to the module caching mechanism."
,255. What is the middleware pattern?,The middleware pattern involves creating a pipeline of functions that process a request in a sequential order. Each middleware function can modify the request/response objects and either pass control to the next function or terminate the request. This pattern is central to frameworks like Express and Koa.
,256. What is dependency injection and how can it be used in Node.js?,"Dependency Injection (DI) is a design pattern where a component's dependencies (e.g., a database service or logger) are ""injected"" from an external source rather than being created by the component itself. This promotes loose coupling and makes components easier to test and reuse. In Node.js, you can implement DI manually by passing dependencies as function arguments or constructor parameters, or by using a DI container library."
,257. What are design patterns and why are they useful?,"Design patterns are reusable, general solutions to commonly occurring problems within a given context in software design. They are not finished designs that can be transformed directly into code but are templates for how to solve a problem. They are useful because they provide a common vocabulary and proven solutions for building robust and maintainable software."
XIV. V8 and Libuv,258. What is the role of Libuv in Node.js?,"Libuv is a C library that provides Node.js with access to the underlying operating system's asynchronous I/O capabilities. It is responsible for handling the event loop, the thread pool for offloading expensive tasks, and abstracting non-blocking I/O operations across different platforms (Windows, macOS, Linux)."
,259. How does Libuv handle asynchronous operations?,"Libuv uses the best available asynchronous mechanism on each operating system (e.g., epoll on Linux, kqueue on macOS, I/O completion ports on Windows). For operations that don't have a non-blocking equivalent in the OS (like fs operations or some crypto functions), it uses a thread pool to run them without blocking the main event loop."
,260. What is the thread pool in Libuv and what is it used for?,"The thread pool is a pool of a few threads (default is 4) managed by Libuv. It is used to run expensive operations that have no native asynchronous counterpart in the operating system, such as certain file system APIs (fs), DNS lookups (dns.lookup), and some crypto functions. This prevents these synchronous tasks from blocking the main event loop."
,261. How does V8 compile and execute JavaScript code?,"V8 compiles JavaScript directly to native machine code before executing it. It uses a JIT (Just-In-Time) compiler that includes multiple tiers. Code starts in an interpreter (Ignition), and if it becomes ""hot"" (frequently executed), it's sent to an optimizing compiler (TurboFan) to generate highly optimized machine code."
,262. What is the V8 heap and stack?,"The Stack is a region of memory used for static data, including function frames, primitive values (like numbers and booleans), and pointers to objects. It is managed by the OS and has a fixed size. The Heap is where V8 stores objects or dynamic data. It is a larger region of memory, and its management (allocation and garbage collection) is handled by V8."
,263. What are hidden classes in V8?,"Hidden classes (or shapes) are an internal mechanism V8 uses to optimize property access. When you create an object, V8 creates a hidden class. If you then create another object with the same properties in the same order, V8 will reuse that hidden class. This allows V8 to access properties using a fixed offset, which is much faster than dictionary lookups."
,264. What is inline caching in V8?,"Inline Caching (IC) is an optimization technique where V8 caches the results of recent method lookups. When a function is called, V8 makes an assumption about the type of object it will be called on (based on past executions) and ""inlines"" the lookup. If the assumption is correct, execution is very fast. If not, V8 de-optimizes and performs a full lookup."
,265. How does V8's garbage collector work (mentioning scavenge and mark-sweep)?,"V8's GC is generational. New objects are allocated in the ""young generation,"" which is small and frequently garbage collected using a fast ""scavenge"" algorithm (which copies surviving objects). Objects that survive long enough are promoted to the ""old generation,"" which is collected less frequently by a slower ""mark-sweep-compact"" algorithm that marks live objects, sweeps dead ones, and compacts memory to reduce fragmentation."
,266. How can you get low-level information about V8's performance?,"You can use the built-in v8 module in Node.js, which provides functions like v8.getHeapStatistics() and v8.getHeapSpaceStatistics() to get detailed information about memory usage. Additionally, command-line flags like --trace-gc or --trace-opt can provide verbose logs about garbage collection and JIT optimization events."
XV. Miscellaneous,267. What are WebSockets and how do they work?,"WebSockets provide a full-duplex communication channel over a single, long-lived TCP connection. They start with an HTTP ""Upgrade"" request from the client. Once the server agrees, the connection is upgraded from HTTP to the WebSocket protocol, allowing for persistent, low-latency, two-way communication between the client and server."
,"268. How can you implement WebSockets in a Node.js application (e.g., using ws or Socket.IO)?","You can use a library like ws, which provides a robust WebSocket implementation. Alternatively, Socket.IO is a higher-level library that provides WebSocket-like functionality with additional features like fallback to long-polling for older browsers, automatic reconnection, and broadcasting to rooms."
,269. What is HTTP/2 and what are its benefits over HTTP/1.1?,"HTTP/2 is a major revision of the HTTP protocol. Its key benefits include: Multiplexing (sending multiple requests and responses over a single TCP connection), Server Push (sending resources the client hasn't requested but will likely need), Header Compression (reducing overhead), and being a binary protocol (more efficient to parse)."
,270. How can you use HTTP/2 in a Node.js application?,"You can use Node.js's built-in http2 core module. It provides an API similar to the https module for creating secure HTTP/2 servers. You typically need to provide SSL/TLS certificates to use HTTP/2, as most browsers only support it over HTTPS."
,271. What is gRPC and how does it compare to REST and GraphQL?,"gRPC is a modern, high-performance open-source RPC (Remote Procedure Call) framework that can run in any environment. It uses Protocol Buffers (Protobufs) as its interface definition language and HTTP/2 for transport. Compared to REST/GraphQL, it is generally faster and more efficient, especially for internal microservice communication, but is less flexible for public-facing APIs due to its stricter contract-first approach."
,272. What are some popular logging libraries for Node.js?,"Popular logging libraries include Winston, Pino (known for very high performance), and Bunyan. These libraries provide features like different log levels, customizable output formats (like JSON), and transports for sending logs to files, databases, or external logging services."
,"273. What is the difference between console.log, console.error, and console.warn?","console.log() is used for general output of logging information. console.warn() is used for outputting warning messages. console.error() is used for outputting error messages. Functionally, they are similar, but warn and error write to the stderr stream, while log writes to stdout. Using them appropriately helps in filtering and redirecting log outputs."
,274. How can you debug a Node.js application?,"You can use the built-in Node.js Inspector by running your script with the --inspect or --inspect-brk flag. This allows you to connect a debugger, like Chrome DevTools or VS Code's debugger, to step through your code, inspect variables, and set breakpoints. console.log is also a common, simpler debugging technique."
,275. What is the Node.js Inspector?,"The Node.js Inspector is a debugging interface that allows you to connect debugging tools to your Node.js process. It uses the Chrome DevTools protocol, enabling you to use familiar tools like the Chrome browser's debugger to profile and debug your backend code."
,276. What is the role of a .nvmrc file?,"A .nvmrc file is used to specify the version of Node.js that a project is intended to be used with. When you are in the project's directory, you can run the command nvm use, and Node Version Manager (nvm) will automatically switch to the Node.js version specified in the .nvmrc file."
,277. What is DNS resolution in Node.js?,DNS (Domain Name System) resolution is the process of translating a human-readable domain name (like google.com) into a machine-readable IP address (like 172.217.167.78). Node.js provides the dns module with functions like dns.lookup() and dns.resolve() to perform these lookups.
,278. What is the os module used for?,"The os module is a core Node.js module that provides operating system-related utility methods and properties. It can be used to get information about the system's CPU architecture (os.arch()), total memory (os.totalmem()), home directory (os.homedir()), and network interfaces (os.networkInterfaces())."
,279. What is the path module and why is it useful?,"The path module is a core Node.js module that provides utilities for working with file and directory paths. It is useful because it provides a cross-platform way to handle paths (e.g., using path.join() instead of string concatenation with / or \), ensuring that your code works correctly on both Windows and POSIX-based systems."
,280. What is the difference between path.join() and path.resolve()?,"path.join([...paths]) joins all given path segments together using the platform-specific separator and normalizes the resulting path. path.resolve([...paths]) resolves a sequence of paths or path segments into an absolute path. It processes the sequence from right to left, with each subsequent path prepended until an absolute path is constructed."
XVI. File System (fs module),281. What is the fs module in Node.js?,"The fs module is a core Node.js module that enables you to interact with the file system. It provides methods for reading, writing, updating, and deleting files and directories."
,282. How do you read a file synchronously? What are the drawbacks?,"You can read a file synchronously using fs.readFileSync('path/to/file', 'utf8'). The main drawback is that it is a blocking operation. It will block the entire event loop, making the application unresponsive until the file has been completely read. This should be avoided in a server environment."
,283. How do you read a file asynchronously?,"You read a file asynchronously using fs.readFile('path/to/file', 'utf8', (err, data) => { ... }). This method is non-blocking. Node.js will read the file in the background and execute the callback function with the file's content once it's finished, without stopping the rest of the application."
,284. How do you write to a file using fs.writeFile()?,"fs.writeFile('path/to/file', 'content', (err) => { ... }) asynchronously writes data to a file. If the file already exists, it will be overwritten. If it doesn't exist, it will be created."
,285. What is the difference between fs.writeFile() and fs.appendFile()?,"fs.writeFile() will create a new file (or overwrite an existing one) with the specified content. fs.appendFile() will append the content to the end of an existing file. If the file does not exist, it will be created."
,286. How do you check if a file exists?,"The recommended modern approach is to use fs.access() to check file permissions, or simply try to operate on the file (e.g., read it) and handle the error if it doesn't exist. The older fs.exists() method is deprecated."
,287. How do you create a directory?,"You can create a directory asynchronously with fs.mkdir('path/to/directory', { recursive: true }, (err) => { ... }). The recursive: true option allows it to create parent directories if they don't exist, similar to mkdir -p."
,288. How do you read the contents of a directory?,"You can read the contents of a directory asynchronously with fs.readdir('path/to/directory', (err, files) => { ... }). The files argument in the callback will be an array of the names of the files in the directory."
,289. How do you delete a file?,"You can delete a file asynchronously using fs.unlink('path/to/file', (err) => { ... })."
,290. How do you rename a file or directory?,"You can rename a file or directory asynchronously using fs.rename('old/path', 'new/path', (err) => { ... }). This can also be used to move a file to a different directory on the same file system."
,291. What is the difference between fs.readFile() and fs.createReadStream()?,"fs.readFile() reads the entire content of a file into a buffer in memory before making it available. This can be memory-intensive for large files. fs.createReadStream() reads the file in small, manageable chunks (a stream), allowing you to process large files without using much memory."
,292. How do you handle errors when working with the fs module?,"For asynchronous methods, you must use the standard error-first callback pattern, where the first argument to the callback is an error object. if (err) { ... }. For synchronous methods, you must use a try...catch block to handle any errors that are thrown."
,293. What is a file descriptor?,A file descriptor is a number (an integer) that uniquely identifies an open file in a computer's operating system. The fs module uses file descriptors to interact with files after they have been opened with fs.open().
,294. Explain the purpose of fs.stat() and what information it provides.,"fs.stat('path', (err, stats) => { ... }) is used to get metadata about a file or directory. The stats object it returns contains information like the file size (stats.size), whether it's a file (stats.isFile()) or a directory (stats.isDirectory()), and timestamps for creation, modification, and last access."
,295. How can you watch for changes in a file or directory?,"You can use fs.watch('path', (eventType, filename) => { ... }) to watch for changes. It's more efficient than fs.watchFile() as it relies on the operating system's native file change notifications."
,296. What is the difference between fs.watch() and fs.watchFile()?,"fs.watch() uses the underlying operating system's features to get notifications about file changes, which is very efficient. fs.watchFile() works by pollingperiodically checking the file's stats to see if it has changedwhich is less efficient and should be avoided if possible."
,297. How would you recursively delete a directory and its contents?,"As of Node.js v14.14.0, you can use fs.rm('path/to/dir', { recursive: true, force: true }, callback). In older versions, you would have to manually read the directory, delete the files inside, and then delete the directory itself, often requiring a recursive function."
,298. Explain the flags option in functions like fs.open() or fs.writeFile().,"The flags option is a string that specifies the mode in which a file should be opened. For example, 'r' is for reading, 'w' is for writing (overwriting), 'a' is for appending, and 'r+' is for reading and writing. These flags control what operations are permitted on the file."
,299. How do you work with file permissions in Node.js?,"You can read file permissions using fs.stat(), which provides the mode in octal format. You can change file permissions using fs.chmod('path', mode, callback), where mode is an octal number like 0o755."
,300. What are some best practices for file system operations in a high-traffic application?,"Always use the asynchronous methods (readFile, writeFile) to avoid blocking the event loop. For large files, always use streams (createReadStream, createWriteStream) to minimize memory usage. Handle all errors properly to prevent crashes. Be mindful of file descriptor limits on the operating system."
XVII. Networking,301. What is the net module used for?,The net module is a core Node.js module used for creating TCP servers and clients. It provides an asynchronous network API for creating stream-based network applications.
,302. How do you create a simple TCP server?,"You use net.createServer() and pass it a callback that handles new connections. In the callback, you get a socket object for each client. You then call .listen() on the server object to start accepting connections. net.createServer((socket) => { socket.write('hello'); }).listen(3000);"
,303. How do you create a TCP client?,"You use net.createConnection() or net.connect() and provide the port and host. This returns a socket object that you can use to send (socket.write()) and receive (socket.on('data', ...) data."
,304. What is the purpose of the http module?,"The http module is a core Node.js module for creating HTTP servers and clients. It provides a higher-level API than the net module, specifically for working with the HTTP protocol."
,305. What is the difference between http.createServer() and http.request()?,http.createServer() is used on the server side to create an HTTP server instance that listens for and handles incoming requests. http.request() is used on the client side to make an outgoing HTTP request to another server.
,306. How do you make an HTTP GET request from a Node.js application?,"You can use http.get('http://example.com', (res) => { ... }), which is a simpler method for GET requests. For other methods, you use http.request(). Alternatively, you can use third-party libraries like axios or the built-in fetch API (available globally in recent Node.js versions)."
,307. How do you handle data chunks in an HTTP request/response?,"HTTP requests and responses are streams. You listen for the data event to receive data in chunks (req.on('data', (chunk) => ...)). When all chunks have arrived, the end event is fired. You typically collect the chunks and concatenate them in the end event handler."
,308. What is the https module and how does it differ from http?,"The https module is for creating HTTPS servers and clients, which is HTTP over a secure (TLS/SSL) connection. Its API is almost identical to the http module, but it requires an options object with SSL certificate details (key and cert) to create a secure server."
,309. Explain how to handle a POST request with the http module without using a framework like Express.,"You would create an HTTP server, check if req.method === 'POST', and then listen for data events on the request object to collect the incoming body chunks. In the end event handler, you would concatenate the chunks into a complete string or buffer and then process the POST data."
,310. What are sockets?,"In the context of the net module, a socket is an object representing one end of a two-way communication link between two programs running on the network. It is a stream, so it can be read from and written to."
,311. How do you handle socket errors in the net module?,"You should always attach an error event listener to the socket object: socket.on('error', (err) => { ... }). An unhandled error event on a socket will cause the Node.js process to crash."
,312. What is the dgram module used for?,"The dgram module is used for implementing UDP (User Datagram Protocol) datagram sockets. It allows for sending and receiving messages over an unreliable, connectionless protocol."
,313. What is the difference between TCP and UDP? When would you use one over the other?,"TCP (Transmission Control Protocol) is connection-oriented, reliable, and ordered. It guarantees that data arrives intact and in order. Use it for applications where data integrity is critical (e.g., file transfers, web Browse). UDP (User Datagram Protocol) is connectionless, unreliable, and unordered. It's faster but doesn't guarantee delivery. Use it for applications where speed is more important than reliability (e.g., live video streaming, online gaming, DNS)."
,314. How do you create a UDP server and client?,"You use the dgram module. A UDP socket is created with dgram.createSocket('udp4'). A server listens for messages using .bind(port) and the 'message' event. A client sends messages using .send(message, port, host). Unlike TCP, there is no persistent connection."
,315. How do you handle URL parsing in Node.js?,"You can use the built-in URL class. const myURL = new URL('http://example.com/foo?bar=baz'); creates a URL object with properties like protocol, hostname, pathname, and searchParams that you can easily access. The older url.parse() method is now legacy."
,316. What are the key properties of the URL object?,"Key properties include: href (the full URL string), protocol, username, password, host, hostname, port, pathname, search, and searchParams (a URLSearchParams object for easy query string manipulation)."
,317. How do you implement HTTPS in your Node.js server? What is required?,"You use the https module instead of http. To create an HTTPS server with https.createServer(), you must provide an options object containing at least two properties: key (the private key for your SSL certificate) and cert (your primary SSL certificate)."
,318. What is Agent Pooling and http.Agent?,"http.Agent is responsible for managing connection persistence and reuse for HTTP clients. By default, Node.js uses a global Agent that keeps a pool of sockets for future requests to the same host, which improves performance by avoiding the overhead of creating new TCP connections for every request. This is known as agent pooling or connection pooling."
,319. How do you set custom headers on an HTTP request?,"When using http.request(), you can pass a headers object in the options: const options = { hostname: '...', path: '...', method: 'GET', headers: { 'Custom-Header': 'value' } };. When using a library like axios, you would pass a headers object in the configuration."
,320. How do you handle timeouts in HTTP requests?,"You can set a timeout on the request object itself using req.setTimeout(ms, callback) or by setting the timeout property in the options for http.request(). If the timeout is reached, the request will be aborted and the timeout callback or timeout event will be emitted."
XVIII. Modern JavaScript,321. Explain let and const and how they differ from var.,"let and const are ES6 variable declarations that are block-scoped ({}). var is function-scoped. let allows you to declare variables that can be reassigned. const declares variables that cannot be reassigned (they are constant references). Variables declared with var are hoisted and initialized with undefined, while let and const are hoisted but not initialized, creating a ""temporal dead zone."""
,322. What is block scope?,"Block scope is the area within if, switch conditions or for and while loops, or any code block enclosed in curly braces {}. Variables declared with let and const are only accessible within the block they are defined in."
,323. Explain destructuring for objects and arrays.,"Destructuring is a syntax that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. For arrays: const [a, b] = [10, 20];. For objects: const { name, age } = { name: 'Alice', age: 30 };."
,324. What are default parameters in functions?,"Default parameters allow you to initialize function parameters with default values if no value or undefined is passed. Example: function greet(name = 'Guest') { return \Hello, ${name}`; }`."
,325. What are rest parameters and the spread syntax?,Rest Parameters (...): Collects all remaining arguments passed to a function into a single array. It must be the last parameter. function sum(...numbers) { ... }. Spread Syntax (...): Expands an iterable (like an array or string) into individual elements. It's used for making shallow copies of arrays/objects or for passing array elements as individual arguments to a function.
,326. What are Classes in ES6? How do they relate to prototypal inheritance?,"ES6 classes are syntactic sugar over JavaScript's existing prototype-based inheritance. The class syntax provides a clearer and more familiar way to create objects and deal with inheritance, but it does not introduce a new object-oriented inheritance model. Under the hood, it still uses prototypes."
,327. Explain the concept of super() in classes.,super() is used in a class constructor to call the constructor of its parent class. It must be called before the this keyword can be used in a subclass's constructor. You can also use super.methodName() to call a method on the parent class.
,328. What are Map and Set? How do they differ from objects and arrays?,"Map: A collection of keyed data items, like an Object. However, a Map allows keys of any type (not just strings/symbols) and maintains the insertion order of its elements. Set: A collection of unique values of any type. Unlike an Array, a value in a Set may only occur once."
,329. What are WeakMap and WeakSet?,"They are ""weak"" versions of Map and Set. WeakMap and WeakSet can only store objects and hold ""weak"" references to them. This means that if an object stored in a WeakMap/WeakSet has no other references in the program, it can be garbage collected. This is useful for preventing memory leaks."
,330. What is optional chaining (?.)?,"The optional chaining operator (?.) allows you to read the value of a property located deep within a chain of connected objects without having to explicitly validate that each reference in the chain is valid. If a reference is null or undefined, the expression short-circuits and returns undefined."
,331. What is the nullish coalescing operator (??)?,"The nullish coalescing operator (??) is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand. It's a way to provide a default value for null or undefined without treating 0 or '' (empty string) as falsy values like the `"
,332. What are Symbols?,"A Symbol is a built-in object whose constructor returns a unique, immutable, primitive value. Symbols are often used as unique property keys for objects to avoid naming collisions."
,333. Explain iterators and generators.,"Iterator: An object that knows how to access items from a collection one at a time, while keeping track of its current position. It has a next() method that returns an object with value and done properties. Generator: A special type of function (declared with function*) that can be paused and resumed, allowing it to produce a sequence of values over time. It returns an iterator. The yield keyword is used to pause execution and return a value."
,334. How do ES Modules (import/export) differ from CommonJS (require/module.exports)?,"ES Modules: Asynchronous, static (must be at the top level), uses import/export keywords, the standard for modern browsers and Node.js. CommonJS: Synchronous, dynamic (can be called anywhere in the code), uses require/module.exports, the traditional module system in Node.js."
,335. Can you use top-level await in Node.js?,"Yes, starting from Node.js v14.8.0, you can use await at the top level of ES modules without needing to wrap it in an async function. This is useful for initializing applications that need to perform asynchronous setup tasks."
XIX. Tooling and Ecosystem,336. What is nvm or n and why is it useful?,"nvm (Node Version Manager) and n are command-line tools used to manage multiple active Node.js versions on the same machine. They are useful for switching between different Node.js versions required by different projects, allowing you to easily install, uninstall, and select the Node.js version to use."
,337. What is a linter? Name a popular one used for JavaScript.,"A linter is a tool that statically analyzes code to find programming errors, bugs, stylistic errors, and suspicious constructs. It helps enforce coding standards and improve code quality. A very popular linter for JavaScript is ESLint."
,338. What is a formatter? Name a popular one.,"A formatter is a tool that automatically reformats code to conform to a specific style guide, handling things like indentation, spacing, and line breaks. A very popular and opinionated code formatter is Prettier."
,339. What is the purpose of a nodemon?,nodemon is a utility that automatically restarts your Node.js application when it detects file changes in the directory. This is extremely useful during development as it saves you from manually stopping and restarting the server after every code change.
,340. What is yarn and how does it compare to npm?,"Yarn is an alternative package manager for Node.js, similar to npm. It was created to address some of npm's earlier shortcomings, offering faster performance (through parallel installs and caching) and more deterministic installs (via a yarn.lock file). While npm has since adopted many of these features, some developers still prefer Yarn's speed and CLI."
,341. What is the purpose of a .gitignore file?,"A .gitignore file specifies intentionally untracked files and directories that Git should ignore. This is used to prevent generated files (like node_modules, log files, or build outputs) from being committed to the version control repository."
,342. What is a task runner like Gulp or Grunt? Are they still relevant?,"Task runners like Gulp and Grunt are tools used to automate development tasks such as minifying CSS/JavaScript, compiling Sass, and optimizing images. While they were once essential, their relevance has decreased as many of their functions are now handled more efficiently by npm scripts or integrated into module bundlers like Webpack."
,"343. What is a module bundler like Webpack, Rollup, or Parcel?","A module bundler is a tool that takes your JavaScript modules and their dependencies and bundles them into one or more optimized files for the browser. This process can include transpiling, minifying, and other optimizations. Webpack is the most popular, Rollup is known for efficient ""tree shaking,"" and Parcel is known for its zero-configuration setup."
,344. Do you need a bundler for a backend Node.js application? Why or why not?,"Generally, no. Node.js understands CommonJS and ES Modules natively, so there's no need to bundle them for compatibility as you would for a browser. However, a bundler might be used in specific backend scenarios, such as for serverless functions to reduce the package size and improve startup time, or when using TypeScript to compile everything into a single file."
,345. What is Babel and what is its primary purpose?,Babel is a JavaScript transpiler. Its primary purpose is to convert modern ECMAScript (ES6+) code into a backward-compatible version of JavaScript that can run in older browsers or environments that don't support the latest features.
,346. What are source maps?,"A source map is a file that maps the code within a transformed/minified file back to its original source code. This is crucial for debugging, as it allows developers to see their original, readable code in the browser's debugger instead of the compiled and optimized code."
,347. What is tree shaking?,"Tree shaking is a form of dead code elimination. It's a process used by module bundlers (like Rollup and Webpack) to remove unused code from the final bundle. By analyzing import and export statements, it only includes the code that is actually used, which can significantly reduce the final file size."
,348. Explain the concept of monorepos and tools like Lerna or Nx.,"A monorepo is a software development strategy where code for many different projects is stored in the same repository. Tools like Lerna and Nx are specialized tools for managing monorepos. They help with tasks like managing dependencies across projects, running commands on multiple packages at once, and simplifying the process of publishing packages."
,349. What is Docker and how can it be used with Node.js applications?,"Docker is a platform for developing, shipping, and running applications in containers. A container packages an application and all its dependencies (like the Node.js runtime) into a standardized unit. This ensures that the Node.js application runs consistently across different environments, from development to production."
,350. What is a Dockerfile? What are some common instructions for a Node.js app?,"A Dockerfile is a text file that contains instructions for building a Docker image. Common instructions for a Node.js app include: FROM node:18 (specifying the base image), WORKDIR /app (setting the working directory), COPY package*.json ./ (copying dependency manifests), RUN npm ci (installing dependencies), COPY . . (copying app source code), and CMD [""node"", ""server.js""] (specifying the command to run)."
,351. What is Continuous Integration (CI) and Continuous Deployment (CD)?,"CI is the practice of automatically building and testing code every time a developer commits changes to version control. This helps find and fix bugs early. CD is the practice of automatically deploying all code changes that pass the CI stage to a testing or production environment. Together, they form a pipeline that automates the software release process."
,352. How would you set up a basic CI pipeline for a Node.js project?,"A basic CI pipeline (using a tool like GitHub Actions or Jenkins) would: 1. Trigger on every push to the main branch. 2. Set up the correct Node.js version. 3. Install dependencies using npm ci. 4. Run the linter (npm run lint). 5. Run automated tests (npm test). 6. Optionally, build the application (npm run build). The pipeline fails if any step fails."
XX. Scenario-Based,353. Describe the architecture of a Node.js application you have worked on. What were the trade-offs?,"Answer is personal and depends on experience. A sample answer: ""I worked on a RESTful API for a social media application using a microservices architecture. We used Express.js for the API gateway and several backend services (for users, posts, notifications). Communication was handled via RabbitMQ. The trade-off was increased operational complexity (deployment, monitoring) in exchange for better scalability and fault isolation compared to a monolith."""
,354. Your Node.js application is running slow. How would you go about diagnosing the problem?,"1. Analyze: Is it CPU-bound or I/O-bound? Check metrics like CPU usage, memory, and event loop lag. 2. Profile: Use a profiler like Clinic.js or Node's built-in profiler to find CPU bottlenecks (long-running synchronous code). 3. Trace I/O: Use tools to trace slow database queries or API calls. 4. Check Event Loop: High event loop lag indicates blocking operations. 5. Check Memory: Look for memory leaks using heap snapshots."
,355. You have a memory leak in production. What are the steps you would take to find and fix it?,"1. Confirm the leak: Monitor the process's memory usage over time to see if it consistently increases. 2. Get Heap Snapshots: Use node-heapdump or the built-in inspector to capture heap snapshots from the production-like environment at different times (e.g., before and after a spike in usage). 3. Analyze the Snapshots: Load the snapshots into Chrome DevTools and compare them. Look for objects whose count is growing without reason. 4. Identify the Source: Trace the retaining path of the leaking objects to find the root cause in the code (e.g., a global array, an un-cleared cache, or an event listener that's never removed). 5. Fix and Verify: Fix the code and then re-run the tests/monitoring to verify the leak is gone."
,356. How would you design a real-time chat application using Node.js? What technologies would you use?,"I would use a Node.js server with Express.js for handling initial HTTP requests and authentication. For the real-time communication, I would use Socket.IO or the ws library for WebSocket connections. On the backend, I'd use a database like MongoDB for storing messages and Redis for managing user session state or for broadcasting messages across multiple server instances in a scaled environment."
,357. Describe how you would build a scalable job queue system in Node.js.,"I would use a dedicated message broker like RabbitMQ or a robust job queue library like BullMQ (which is built on Redis). The main application would act as a ""producer,"" adding jobs (e.g., sending an email, processing a video) to the queue. Separate Node.js processes (""consumers"" or ""workers"") would listen to the queue, pick up jobs, and process them independently. This decouples the long-running tasks from the main application and allows for scaling the number of workers based on the job load."
,"358. You need to perform a long-running, CPU-intensive task in a web request. How would you handle this without blocking the event loop?","The best approach is to offload the task to a separate thread or process. I would use a worker thread (worker_threads module) for the CPU-intensive calculation. The main thread would receive the request, delegate the task to the worker, and then, upon completion, the worker would send the result back to the main thread, which would then send the response to the user. This keeps the main event loop free to handle other requests."
,"359. How would you design a REST API for a resource that has a one-to-many relationship with another resource (e.g., users and their posts)?",I would use nested routes to represent the relationship. - GET /users/:userId/posts: Get all posts for a specific user. - POST /users/:userId/posts: Create a new post for a specific user. - GET /posts/:postId: Get a specific post by its own ID. The post resource should contain a userId field to link back to the user.
,360. A third-party API your application depends on is unreliable. How do you make your application resilient to its failures?,"I would implement the Circuit Breaker pattern. This pattern monitors for failures. After a certain number of failed requests, it ""opens the circuit"" and immediately fails subsequent requests without calling the API, preventing the application from waiting on a failing service. It will periodically try to ""half-open"" the circuit to see if the API has recovered. Additionally, I would implement retries with exponential backoff for transient errors and use caching to serve stale data if the API is down."
,361. How do you ensure code quality in your team's Node.js projects?,By implementing a combination of tools and processes: 1. Linter and Formatter: Enforce a consistent code style with ESLint and Prettier. 2. Automated Testing: Require high unit and integration test coverage. 3. CI Pipeline: Automatically run linting and tests on every commit. 4. Code Reviews: Mandate peer reviews for all pull requests to catch logical errors and improve design. 5. Typing: Use TypeScript or JSDoc for better type safety.
,362. Explain how you would implement logging and monitoring for a production Node.js application.,"Logging: I'd use a structured logging library like Pino to generate JSON logs. Logs would have different levels (info, debug, warn, error) and would be sent to a centralized logging service (like Datadog, ELK stack, or LogDNA) for easy searching and analysis. Monitoring: I'd use an Application Performance Monitoring (APM) tool like New Relic or Datadog to track key metrics like response time, throughput, error rates, and event loop lag. I would also set up alerts for critical issues like high error rates or CPU usage."
,363. You are deploying a Node.js application for the first time. What are the key things you need to consider for a production environment?,"1. Environment Variables: Manage secrets and configuration properly. 2. Process Manager: Use PM2 or a similar tool to keep the app alive and run it in cluster mode. 3. Logging: Set up production-level logging. 4. Security: Use helmet, set up a firewall, and ensure dependencies are secure. 5. Reverse Proxy: Place a reverse proxy like Nginx in front of the app for load balancing and SSL termination. 6. Monitoring & Alerting: Set up tools to monitor health and performance. 7. Build Process: Use npm ci for deterministic dependency installation."
,"364. How would you handle configuration management for different environments (development, staging, production)?","I would use environment variables. A library like dotenv can be used to load variables from a .env file for local development. In staging and production environments, these variables would be set directly on the host machine or through a cloud provider's configuration service. This avoids hardcoding secrets and allows the same codebase to run with different configurations."
,365. Your application's database is under heavy load. What are some strategies you could implement at the application layer to reduce the load?,"1. Caching: Implement a caching layer (e.g., with Redis) to store the results of frequent and expensive queries. 2. Query Optimization: Analyze and optimize slow queries. Ensure proper indexing. 3. Connection Pooling: Use a connection pool to efficiently manage database connections. 4. Data Pagination: Implement pagination for API endpoints that return large lists of data. 5. Read Replicas: If possible, direct read-heavy traffic to a read replica of the database."
,366. What is your opinion on TypeScript vs. plain JavaScript for a large-scale Node.js project?,"For a large-scale project, TypeScript is generally a better choice. Its static typing provides significant benefits: it catches errors at compile-time instead of runtime, improves code readability and maintainability, and enables better autocompletion and refactoring in IDEs. While it adds a compilation step and a learning curve, these overheads are usually outweighed by the long-term benefits in terms of stability and team collaboration on a large codebase."
,367. How do you stay up-to-date with the latest trends and changes in the Node.js ecosystem?,"Answer is personal. A sample answer: ""I regularly read the official Node.js blog and release notes. I follow key figures and publications in the Node.js community on Twitter and subscribe to newsletters like Node Weekly. I also enjoy watching conference talks and occasionally contributing to or exploring open-source projects to see new patterns in practice."""
,368. Describe a time you had to debug a difficult asynchronous issue.,"Answer is personal and depends on experience. A sample answer: ""I once faced an issue where requests would intermittently time out. There were no obvious errors. By adding detailed logs with unique request IDs, I traced the problem to a complex promise chain where a specific .catch() block was not returning a value, causing the chain to hang indefinitely under certain error conditions. Adding a return statement in the catch block resolved the issue."""
,369. How would you handle versioning for your API?,"I would use URI versioning, including the version number in the URL path (e.g., /api/v1/users). This is the most straightforward and common approach. For breaking changes, I would introduce a new version (e.g., /api/v2/) while maintaining the old version for a deprecation period to give clients time to migrate."
,"370. You need to process a very large (e.g., 10GB) CSV file. How would you do this efficiently in Node.js?","I would use streams. I would create a readable stream from the file using fs.createReadStream(), pipe it to a CSV parsing stream (like csv-parser), and then pipe the results to a transform stream to process each row one by one. This approach processes the file in small chunks, using minimal memory, and avoids loading the entire 10GB file at once."
,371. How would you implement rate limiting on your API? What are different strategies?,"I would use middleware like express-rate-limit. Different strategies include: 1. Fixed Window: A simple approach, allows X requests per time window (e.g., 100 requests/hour). 2. Sliding Window: More accurate, counts requests in a rolling window. 3. Token Bucket: Each user has a bucket of tokens that refill over time. Each request consumes a token. 4. Leaky Bucket: Requests are added to a queue (bucket) and processed at a fixed rate."
,372. Describe a situation where using Node.js was a bad choice.,"Node.js is a bad choice for heavy, CPU-intensive, blocking computations without offloading. For example, building a desktop application for complex 3D rendering or scientific modeling would be better suited to a multi-threaded language like C++ or Java, as Node's single-threaded event loop would be completely blocked by the computations, making the application unresponsive."
,373. How would you secure sensitive data like API keys and credentials in your application?,"Sensitive data should never be hardcoded or committed to version control. They should be managed as environment variables. For local development, use a .env file (which is listed in .gitignore). For production, use a secret management service provided by your cloud host (e.g., AWS Secrets Manager, HashiCorp Vault, or the platform's environment variable configuration)."
,374. Explain the pros and cons of using a microservices architecture versus a monolith for a new project.,"Monolith: Pros: Simpler to start, develop, and deploy initially. No network latency between components. Cons: Becomes hard to scale and maintain as it grows; tight coupling makes updates risky. Microservices: Pros: Scalable, flexible technology choices per service, fault isolation. Cons: High initial setup complexity, challenges with distributed transactions, monitoring, and network latency. For a new project, starting with a well-structured monolith and evolving to microservices as needed is often a good strategy."
,375. You've noticed that one of your worker processes in a cluster is consistently crashing. How would you investigate this?,"1. Centralized Logging: Ensure the worker is logging detailed error information (including stack traces) to a centralized location before it crashes. Check these logs for the specific error causing the crash. 2. Reproduce Locally: Try to reproduce the issue in a local environment with the same Node.js version and dependencies. 3. Memory/CPU Profiling: If the crash is due to out-of-memory errors or CPU spikes, attach a profiler to the worker process to investigate. 4. Isolate the Worker: Log the PID of the crashing worker. You could potentially give it a specific workload to see if the crash is related to a certain type of request."
XXI. Deep Dive & Edge Cases,"376. What is libuv's thread pool, and which APIs typically use it?","It's a pool of threads (default size 4) managed by libuv to handle expensive operations that lack a non-blocking equivalent in the underlying OS. It's used by some fs APIs (like fs.readFile), dns.lookup(), and some crypto APIs (like crypto.pbkdf2). These APIs appear asynchronous to the JavaScript code but are actually blocking on a separate thread."
,"377. Can the event loop get ""stuck""? How?","Yes, the event loop can get ""stuck"" or blocked. This happens when you run a long-running, synchronous piece of code on the main thread. Examples include complex calculations in a tight loop, synchronous I/O operations (fs.readFileSync), or a regular expression that is subject to ""catastrophic backtracking."" While it's stuck, Node.js cannot handle any other events."
,"378. Explain the concept of ""monkey patching"" in Node.js. When might it be used or discouraged?","Monkey patching is the practice of modifying or extending the behavior of existing modules or objects at runtime. For example, you could replace console.log with a custom implementation. It might be used for testing (to mock a function) or for polyfills. It is generally discouraged in production code because it can lead to unpredictable behavior and makes code harder to debug and maintain."
,379. What is the Atomics object and what is its relation to SharedArrayBuffer?,"Atomics is a global object that provides atomic operations for reading and modifying data stored in a SharedArrayBuffer. A SharedArrayBuffer allows memory to be shared between threads (e.g., the main thread and a worker thread). Atomics ensures that these operations are performed without being interrupted, preventing race conditions when multiple threads access the same memory location."
,380. How does Node.js handle DNS resolution internally?,"Node.js has two main DNS methods: dns.lookup(), which uses the underlying OS's getaddrinfo system call (and can use libuv's thread pool, making it blocking on a worker thread), and dns.resolve(), which performs an actual DNS query to a DNS server over the network and is always non-blocking. http requests use dns.lookup() by default."
,"381. What is the difference between Buffer.from(str) and Buffer.from(str, 'utf8')?","There is no functional difference. When a string is passed to Buffer.from(), 'utf8' is the default encoding. Specifying it explicitly just makes the code clearer but does not change the outcome. Both will create a buffer representing the UTF-8 encoded bytes of the string."
,382. How can you read a specific range of bytes from a large file without loading the entire file?,"You would use fs.createReadStream() with start and end options. fs.createReadStream('large.file', { start: 100, end: 199 }) will create a stream that reads only the 100 bytes from the specified range."
,383. What is the string_decoder module used for?,"The string_decoder module is used to decode buffers into strings in a way that correctly handles multi-byte UTF-8 characters that might be split across chunks. If a multi-byte character is split between two buffer chunks, string_decoder will internally hold the incomplete bytes and wait for the next chunk to complete the character, preventing corruption."
,384. Explain the unref() and ref() methods on timer objects.,"Timers (from setTimeout or setInterval) normally keep the Node.js event loop alive. Calling .unref() on a timer object allows the program to exit even if the timer is still active. Calling .ref() on an ""unreferenced"" timer will restore its default behavior, forcing the program to wait for it. This is useful for long-running background tasks that shouldn't keep the application alive on their own."
,385. How do C++ addons work in Node.js? What is N-API?,"C++ addons are dynamically-linked shared objects, written in C++, that can be loaded into Node.js using require(). They provide a way to interface with C++ libraries or write performance-critical code. N-API is an ABI-stable (Application Binary Interface) C API for building native addons. It abstracts away the underlying V8 changes, meaning addons built with N-API are more likely to work across different Node.js versions without needing to be recompiled."
,"386. What is the Global Interpreter Lock (GIL) in other languages, and why is its absence in Node.js (for JavaScript) significant?","The GIL is a mutex used in languages like CPython that prevents multiple native threads from executing interpreter bytecodes at the same time, effectively making the interpreter single-threaded. Node.js (V8) does not have a GIL for JavaScript execution. This is significant because while JavaScript itself is single-threaded, Node.js can achieve concurrency for I/O operations through its event-driven model and libuv. For CPU-bound tasks, it uses worker threads, which run in parallel without a GIL."
,387. How can you implement a graceful shutdown in a Node.js server?,"A graceful shutdown ensures all ongoing requests are finished and resources are cleaned up before the process exits. You listen for termination signals like SIGINT (Ctrl+C) and SIGTERM. In the signal handler, you: 1. Stop the server from accepting new connections (server.close()). 2. Close database connections, etc. 3. Wait for existing connections to finish. 4. Finally, exit the process (process.exit(0))."
,388. What happens to in-flight requests when a Node.js process crashes?,"When the process crashes, the underlying TCP connections are abruptly terminated. The clients who made those in-flight requests will receive a connection reset error. There is no graceful response. This is why using a process manager to restart the process and a reverse proxy/load balancer to redirect traffic is crucial for reliability."
,389. What is the purpose of the .mjs and .cjs file extensions?,They provide an unambiguous way to tell the Node.js runtime whether a file is an ES Module or a CommonJS module. .mjs files are always treated as ES Modules (import/export). .cjs files are always treated as CommonJS modules (require/module.exports). This is useful when you need to mix module types in a project.
,390. Explain how async_hooks can be used.,"async_hooks is an experimental core API that provides insight into the lifecycle of asynchronous resources in a Node.js application. It can be used to track when async operations are initiated, when they complete, and what caused them. A common use case is to implement continuation-local storage, allowing you to track a request's context (like a request ID) across multiple async operations without passing it as a parameter."
,391. What is continuation-local storage and what problem does it solve?,"Continuation-local storage (CLS) is a mechanism to store state that is specific to a single asynchronous execution chain (like an HTTP request). It solves the problem of tracking context (e.g., a transaction ID or user session) through a series of asynchronous calls without having to pass the context object as a parameter to every function in the chain. The async_hooks module provides the foundation for implementing this."
,392. How does Error.captureStackTrace work?,"Error.captureStackTrace(targetObject[, constructorOpt]) is a V8-specific function that creates a .stack property on a targetObject. It captures a snapshot of the call stack at the current position. It's often used when creating custom error classes to provide a meaningful stack trace that starts from where the error was instantiated, not from within the error's constructor itself."
,393. How would you stream data to a child process's stdin?,"When you create a child process with child_process.spawn(), the returned object has a stdin property, which is a Writable stream. You can write data to it like any other Writable stream, or pipe a Readable stream to it. For example: fs.createReadStream('input.txt').pipe(child.stdin);."
,394. What is the Zlib module used for? Give a practical example.,The zlib module provides compression and decompression functionality using the Gzip and Deflate/Inflate algorithms. It provides Transform streams. A practical example is gzipping a file to save disk space or to send a compressed HTTP response: fs.createReadStream('large.log').pipe(zlib.createGzip()).pipe(fs.createWriteStream('large.log.gz'));.
,395. What are the performance implications of using try...catch in a performance-critical function?,"In modern JavaScript engines like V8, the performance cost of a try...catch block is negligible if no exception is thrown. However, when an exception is actually thrown and caught, there is a significant performance penalty because the engine has to unwind the stack and find the catch handler. Therefore, it's fine to use try...catch for error handling, but you should avoid using it for control flow (i.e., regularly throwing and catching errors as a way to direct program logic)."
,"396. What is a ""promisify"" function and how would you write your own?","A ""promisify"" function is a utility that converts a function that uses the error-first callback pattern into a function that returns a promise. Node.js has a built-in util.promisify. A simplified custom implementation would look like this: const promisify = (fn) => (...args) => new Promise((resolve, reject) => fn(...args, (err, result) => err ? reject(err) : resolve(result)));"
,397. How does process.nextTick() queue differ from the promise microtask queue?,"Both are microtask queues, but the process.nextTick() queue is processed before the promise microtask queue within the same tick of the event loop. This means that any callback scheduled with process.nextTick() will always run before any promise .then() or .catch() callback scheduled in the same scope. nextTick can ""starve"" the promise queue if it recursively calls itself."
,398. What is the v8.getHeapStatistics() method useful for?,"v8.getHeapStatistics() returns detailed statistics about the V8 heap, including total heap size, total available heap size, used heap size, heap size limit, and sizes of different memory spaces. It is useful for monitoring the memory footprint of your application and for diagnosing potential memory-related issues."
,"399. Explain the concept of ""fast properties"" vs ""dictionary mode"" for objects in V8.","V8 uses hidden classes to optimize object property access. When properties can be accessed via a fixed offset (because object shapes are consistent), this is ""fast properties"" mode. However, if properties are added and deleted dynamically, or if there are too many properties, V8 will switch the object to ""dictionary mode,"" which uses a slower hash table for property lookups. To keep objects in fast mode, you should initialize all members in the constructor and avoid adding/deleting properties after instantiation."
,400. How could you abuse prototype pollution in a Node.js application?,"Prototype pollution is a vulnerability where an attacker modifies Object.prototype. Since most objects in JavaScript inherit from Object.prototype, this modification can affect the entire application. An attacker could abuse this by, for example, adding a property to Object.prototype that grants them admin privileges, or by overwriting a common method like toString to execute malicious code. This often happens through unsafe merging of JSON objects from user input."
XXII. WebSockets,"401. What is the difference between polling, long-polling, and WebSockets?","Polling involves the client repeatedly asking the server for new data at fixed intervals. Long-polling is where the client makes a request, and the server holds that connection open until it has new data to send. WebSockets provide a single, persistent, bidirectional connection where either the client or server can send data at any time with low latency."
,"402. What is the WebSocket protocol (ws://, wss://)?","It's a communication protocol for creating a two-way, real-time data transfer between a client and a server over a single TCP connection. ws:// is the standard, unencrypted protocol, while wss:// is the secure, encrypted version that uses TLS, similar to how HTTP relates to HTTPS."
,403. How does the initial WebSocket handshake work over HTTP?,"The process, known as an ""Upgrade,"" starts with the client sending a standard HTTP request that includes an Upgrade: websocket header. If the server supports WebSockets, it replies with an HTTP 101 Switching Protocols status. This single handshake transitions the connection from HTTP to the WebSocket protocol."
,404. What is Socket.IO and how does it differ from a standard WebSocket library like ws?,"Socket.IO is a high-level library that enables real-time, event-based communication. It uses WebSockets as its primary transport but automatically falls back to other techniques like long-polling if WebSockets are unavailable. The ws library is a lower-level, minimal WebSocket implementation that does not offer these automatic fallbacks, reconnection logic, or built-in broadcasting."
,405. How do you broadcast a message to all connected clients using Socket.IO?,"You use io.emit('event_name', data);. This command sends the message to every client connected to the server. To send to all clients except the sender, you would use socket.broadcast.emit('event_name', data);."
,"406. What are ""rooms"" in Socket.IO?","Rooms are a server-side concept for grouping sockets. This allows you to broadcast messages to a specific subset of clients, which is useful for applications like chat rooms or collaborative editing where you only want to notify users in a particular session."
,407. How do you handle authentication for a WebSocket connection?,"Authentication is typically performed during the initial HTTP handshake. The client sends credentials (e.g., a JWT in a query parameter or a cookie) with the upgrade request. Server-side middleware can then intercept this request, validate the credentials, and only allow the WebSocket connection to be established if the user is authenticated."
,408. What are some potential challenges with managing state in a real-time application with many concurrent users?,"Key challenges include state synchronization (ensuring all users see consistent data), scalability (managing memory for a large number of connections), race conditions (multiple users modifying the same data simultaneously), and fault tolerance (preserving state if a server instance fails)."
,409. How does backpressure work with WebSockets?,"Backpressure is a mechanism to handle data flow when a sender is faster than the receiver. In WebSockets, the underlying TCP connection handles this automatically. If the receiver's buffers fill up, TCP signals the sender to slow down or pause transmission until the receiver can catch up, preventing memory overload."
,410. What are Server-Sent Events (SSE) and how do they compare to WebSockets?,"Server-Sent Events (SSE) is a technology where a server can push data to a client over a standard HTTP connection. Unlike WebSockets, SSE is unidirectional (server-to-client only). SSE is simpler and uses regular HTTP, making it ideal for updates like news feeds or notifications. WebSockets are necessary for fully bidirectional communication like chat or gaming."
XXIII. GraphQL,411. What are the main problems with REST that GraphQL aims to solve?,"1. Over-fetching: REST endpoints often return more data than the client needs. 2. Under-fetching: Clients frequently need to make multiple API calls to different REST endpoints to gather all required data. 3. Inflexible Structure: REST APIs have fixed data structures, making it hard to evolve the API without versioning (e.g., /v1, /v2)."
,"412. Explain the core concepts of GraphQL: Schema, Queries, Mutations, and Subscriptions.","- Schema: The contract defining the API's capabilities. It specifies the types, fields, and available operations. - Queries: Used to request and fetch data. The client specifies the exact fields it needs. - Mutations: Used to create, update, or delete data, causing a state change on the server. - Subscriptions: Used for real-time communication, allowing the server to push data to the client when specific events occur."
,413. What is the Schema Definition Language (SDL)?,"It's a concise, human-readable language for writing a GraphQL schema. The SDL is used to define object types, fields, and the available queries, mutations, and subscriptions, acting as the blueprint for the API."
,"414. What is a ""resolver"" in the context of a GraphQL server?","A resolver is a function on the server responsible for fetching the data for a single field in the schema. When a query arrives, the GraphQL server executes the corresponding resolvers for each requested field."
,415. How does GraphQL prevent over-fetching and under-fetching of data?,"GraphQL solves this by design. The client sends a query specifying the exact data and fields it requires. The server then responds with a JSON object containing only that requested data, eliminating multiple round-trips (under-fetching) and unnecessary data transfer (over-fetching)."
,"416. What is the N+1 problem in the context of GraphQL, and how can it be solved?","The N+1 problem occurs when fetching a list of items (1 query) and then making a subsequent query for a related field for each of the N items. This is solved using a technique called batching, most commonly implemented with a tool like DataLoader."
,417. What is a tool like DataLoader used for?,"DataLoader is a utility that solves the N+1 problem by batching and caching database lookups. It collects individual data requests made during a single GraphQL query, combines them into a single, efficient request (e.g., SELECT ... WHERE id IN (...)), and then distributes the results back to the correct resolvers."
,418. How do you handle errors in GraphQL?,"GraphQL has a built-in error handling mechanism. If an error occurs while resolving a field, the server returns a JSON response containing both a data key (with any successfully resolved data) and an errors key, which is an array of objects detailing what went wrong."
,419. What are GraphQL subscriptions used for?,"Subscriptions are used to maintain a persistent connection to the server for real-time updates. When a server-side event occurs (like a new message being added), the server can push the relevant data to all subscribed clients. They are typically implemented using WebSockets."
,420. How would you implement authentication and authorization in a GraphQL API?,"Authentication is usually handled once per request by middleware that runs before GraphQL execution. This middleware validates a token (e.g., JWT) and attaches the user's details to a shared context object. Authorization is then handled within individual resolvers, which check the user's permissions from the context object before fetching or modifying data."
XXIV. More on Express.js,421. Explain how to create a chainable route handler for a specific route path.,"You can use app.route('/path') to get a route instance. This allows you to chain HTTP verb methods (.get(), .post(), .put(), etc.) for the same path in a clean, organized way, like so: app.route('/items').get(getItems).post(createItem);."
,422. What is the purpose of res.locals?,res.locals is an object whose properties are scoped to a single request-response cycle. It's a convenient place for middleware to store and pass information (like user authentication data or pre-fetched content) to subsequent middleware or the final route handler without polluting the global scope.
,423. How can you gracefully handle async errors in Express middleware without try-catch blocks in every route?,"Express 5 handles this automatically. For older versions, you can wrap your async route handlers in a higher-order function that catches any rejected promises and passes the error to next(). Alternatively, you can use a simple package like express-async-errors which patches Express to do this for you."
,424. What is the difference between app.route() and express.Router()?,"app.route() creates a chainable route handler for a single path. express.Router() is a mini-application that can have its own middleware and routing system. Routers are used to create modular, mountable route handlers to organize a large application into separate files or components."
,425. How would you implement content negotiation in an Express API?,"Content negotiation allows an API to serve different formats (e.g., JSON, XML) from the same URL based on the client's Accept header. In Express, you can use res.format() which inspects req.accepts() and provides a simple way to send different responses."
,426. What are some security best practices specific to Express?,1. Use Helmet: It sets various HTTP headers to protect against common web vulnerabilities. 2. Sanitize and Validate Input: Use a library like express-validator to prevent injection attacks. 3. Implement CSRF Protection: Use tokens to protect against cross-site request forgery. 4. Secure Cookies: Set httpOnly and secure flags on cookies. 5. Use Rate Limiting: Prevent brute-force attacks by limiting request frequency.
,427. How do you manage file uploads in Express? What libraries are commonly used?,"Express doesn't handle multipart/form-data (file uploads) natively. The standard library for this is Multer. It's middleware that processes the incoming form data and makes the uploaded files available on the req object (e.g., req.file or req.files)."
,428. Explain how to test Express middleware independently.,"To test middleware, you can call it as a plain function, passing in mocked req, res, and next objects. You can use a testing library like Jest or Sinon to create spies for these objects and then assert that next() was called or that res.status() or res.json() were called with the expected values."
,429. What is the purpose of req.app?,req.app holds a reference to the Express application instance that is handling the request. This is useful for accessing app-level settings (defined with app.set()) from within any route handler or middleware in your application.
,430. How can you extend the Express req or res objects?,"You can add custom properties or methods by modifying them inside a middleware. For example, app.use((req, res, next) => { req.user = 'guest'; next(); });. For adding methods that should be available on all requests, you can modify the prototype: express.request.customMethod = function() { ... };."
XXV. Node.js API,431. What is the querystring module and how does it differ from URLSearchParams?,"The querystring module is a legacy Node.js utility for parsing and formatting URL query strings. URLSearchParams is the modern, web-standard API available in both Node.js and browsers. URLSearchParams provides a richer and more standard interface and is generally the recommended choice for new code."
,432. What is the util module? Name some of its useful functions.,"The util module provides various utility functions helpful for developers. Key functions include: util.promisify() to convert callback-style functions into promise-based ones, util.inspect() to get a detailed string representation of an object for debugging, and util.types for advanced type checking."
,433. Explain the purpose of util.promisify().,"Its purpose is to take a function that follows the common error-first callback pattern (i.e., (err, value) => ...) and return a version of that function that returns a promise. This is a powerful tool for modernizing old codebases to use async/await."
,434. What is the crypto module used for? Give an example of creating a hash.,"The crypto module provides cryptographic functionality, including tools for creating hashes, ciphers, signatures, HMACs, and more. To create a hash, you would create a hash instance with a specific algorithm (like 'sha256'), update it with the data you want to hash, and then call a digest() method to get the final hash value in a desired format (like hex)."
,435. How can you create a secure random string in Node.js?,"The best way is to use crypto.randomBytes() to generate cryptographically strong random data, and then encode it as a string (e.g., hex or base64). For example: crypto.randomBytes(20).toString('hex');"
,436. What is the difference between crypto.randomBytes() and crypto.pseudoRandomBytes()?,"crypto.randomBytes() generates cryptographically strong random data and is the secure, recommended method. It may block if the system lacks sufficient entropy. crypto.pseudoRandomBytes() is a deprecated, faster but insecure method that should not be used for anything security-sensitive like keys or tokens."
,437. What is the assert module and when should it be used?,"The assert module provides a simple set of assertion tests, primarily intended for writing unit tests. It checks for invariants. If an assertion fails, it throws an AssertionError. It's a tool for developers to test their code during development, not for handling runtime errors in production."
,438. Explain the timers/promises API.,"The timers/promises API provides promise-based versions of timer functions like setTimeout. This allows you to use async/await for time-based delays in a clean, modern way without callbacks. For example: const { setTimeout } = require('timers/promises'); await setTimeout(2000);."
,439. What is the worker_threads module and what is its primary use case?,"The worker_threads module enables the use of threads to execute JavaScript in parallel. Its primary use case is for offloading CPU-intensive tasks (like complex calculations, data processing, or encryption) from the main event loop, ensuring the main application remains responsive."
,440. How do you share data between worker threads?,"Data can be sent between the main thread and worker threads using postMessage(), which copies the data. For high-performance scenarios where you need to avoid copying, you can share memory directly using SharedArrayBuffer and MessageChannel."
,441. What is the perf_hooks module for?,The perf_hooks (Performance Hooks) module provides an API for measuring the performance of your Node.js application with high-resolution timing. It allows you to mark start and end points in your code to accurately measure the duration of specific operations.
,442. How does the http2 module differ from the http module in usage?,"The http2 module implements the HTTP/2 protocol, offering major performance features over the http (HTTP/1.1) module, such as multiplexing (multiple requests over one connection) and server push. While the basic API is similar, http2 introduces concepts like streams and sessions to manage these advanced features."
,443. What is the repl module used for?,"The repl module is used to create a Read-Eval-Print-Loop environment, just like the interactive node shell. You can use it to build interactive command-line interfaces or debugging consoles directly into your application."
,444. How can you interact with the operating system using the os module?,"The os module provides operating system-related utility methods. You can use it to get information like the number of CPU cores (os.cpus()), total system memory (os.totalmem()), the current user's home directory (os.homedir()), and the OS platform (os.platform())."
,445. What is a TTY (teletypewriter) in the context of Node.js?,"In Node.js, a TTY refers to a terminal or console environment. The tty module's isatty() function can check if a given file descriptor is connected to a TTY. This is useful for determining if a script should render colors or interactive prompts, as you would only do so when a human is running it in a terminal."
XXVI. Code Challenges,446. Write a function that recursively reads all files in a directory and its subdirectories and returns an array of file paths.,"To create such a function, you would use Node.js's fs (file system) and path modules. The function would take a directory path as input. It would read all items in that directory. For each item, it would check if it's a directory or a file. If it's a file, its full path is added to an array. If it's a directory, the function calls itself with the path of that subdirectory, continuing the process until all subdirectories have been explored."
,447. Implement a simple EventEmitter class from scratch.,"You would create a class with a constructor that initializes an events property as an empty object. An on method would take an event name and a listener function; it would store the listener in an array under the corresponding event name in the events object. An emit method would take an event name and data; it would find the array of listeners for that event and execute each one, passing the data to it."
,448. Write a Transform stream that converts incoming string data to uppercase.,"This requires creating a class that extends Node's stream.Transform. You would implement the _transform method, which receives a chunk of data, an encoding, and a callback. Inside this method, you would convert the data chunk to a string, transform it to uppercase, and then use this.push() to pass the modified data to the next stream in the pipeline before finally calling the callback."
,"449. Using only the net module, write a basic HTTP server that responds with ""Hello, World!"".","You would use the net.createServer method. The callback function for the server gives you a socket object for each connection. Inside this callback, you have to manually construct a valid raw HTTP response string, including the status line (HTTP/1.1 200 OK), headers (Content-Type, Content-Length), a blank line, and the body (""Hello, World!""). This full string is then written to the socket."
,450. Create a simple TCP chat server where multiple clients can connect and broadcast messages to each other.,"The approach is to use the net.createServer method. You would maintain a global list or Set to store all connected client sockets. When a new client connects, its socket is added to the list. When any client's socket emits a 'data' event, you would iterate through the list of all clients and write the received data to every other client's socket. You would also need to handle the 'close' event to remove disconnected clients from the list."
,451. Write a function that takes an array of functions that return promises and executes them sequentially.,"A modern approach uses an async function with a for...of loop. You would iterate through the array of promise-returning functions. Inside the loop, you would await the execution of each function, ensuring one completes before the next one starts. The results can be collected in an array. An older approach involves using Array.prototype.reduce to chain the promises together."
,452. Implement a debounce function.,"Debouncing involves creating a higher-order function that returns a new function. This new function uses a variable in its closure to hold a timeout ID. Each time it's called, it first clears the previous timeout (if one exists) and then sets a new timeout. The original function is only executed inside the setTimeout callback, ensuring it only runs after a period of inactivity."
,453. Implement a throttle function.,"Throttling also involves a higher-order function that returns a new function. This function uses a boolean flag in its closure, like isThrottled. When called, it checks the flag. If not throttled, it executes the original function, immediately sets the flag to true, and starts a setTimeout. The timeout's only job is to reset the flag to false after the specified delay has passed, allowing the function to be called again."
,454. Create a worker thread to calculate a Fibonacci number without blocking the main thread.,"The solution involves two files. The main script would import Worker from the worker_threads module. It would create a new Worker, passing the path to a worker script and the number to calculate as workerData. The main script would then listen for the 'message' event from the worker to receive the result. The worker script would import workerData and parentPort, perform the CPU-intensive Fibonacci calculation, and use parentPort.postMessage() to send the result back to the main thread."
,"455. Write a custom middleware in Express to log the request method, URL, and timestamp for every incoming request.","You would write a function that accepts three arguments: req, res, and next. Inside this function, you would get the current timestamp, access the request method and URL from the req object (e.g., req.method, req.url), and log this information to the console. The final and most important step is to call next() to pass control to the next middleware in the chain."
,456. Write a Node.js script that pipes a gzipped file from the file system to an HTTP response.,"The solution involves streams. You would create an HTTP server. In the request handler, you would first set the Content-Encoding: gzip header on the response (res). Then, you would create a readable stream from a file using fs.createReadStream(). This stream would be piped into a zlib.createGzip() transform stream, which would then be piped into the HTTP response object (res)."
,457. How would you flatten a deeply nested array without using .flat()?,"A common solution is a recursive function. This function would iterate over the input array. For each element, it checks if the element is an array itself. If it is, the function calls itself with that element as the new input, effectively diving deeper. If the element is not an array, it is pushed into a result array. The results from the recursive calls are concatenated to form the final flat array."
,458. Write a function to check if two objects are deeply equal.,"This requires a recursive function. It would first handle base cases: if the two inputs are strictly equal, they are equal. If they are not objects or are null, they are not equal. Then, it compares the number of keys in both objects. If they differ, the objects are not equal. Finally, it iterates through the keys of one object, checking if the other object has the same key and recursively calling the deep equal function on the values of those keys."
,459. Implement a simple caching mechanism using a Map and setTimeout for expiration.,"You would create a class to manage the cache. Internally, this class would use a Map to store key-value pairs. The set method would not only add the item to the Map but also use setTimeout to schedule the deletion of that key from the Map after the specified time-to-live (TTL) has passed. The get method would simply retrieve the value from the Map, returning null or undefined if it's not present."
,460. Write a regex to validate an email address. Discuss its limitations.,"A simple regex would consist of three parts: a local part, an @ symbol, and a domain part. The local part would match one or more characters that are not a space or @. The domain part would match one or more characters, followed by a dot, followed by more characters. Limitations: This is highly simplistic and not compliant with official standards (RFC 5322). It would fail on valid emails with special characters like + and would pass invalid emails like a@b.c. True email validation is notoriously complex and best handled by sending a verification link."
,"461. Describe what is happening in the event loop with this code: setTimeout(() => console.log('A'), 0); Promise.resolve().then(() => console.log('B')); process.nextTick(() => console.log('C')); console.log('D');","Output: D, C, B, A &lt;br> Explanation: &lt;br> 1. console.log('D') is synchronous code and runs first. &lt;br> 2. process.nextTick('C') is scheduled in the nextTick queue, which runs immediately after the current synchronous code and before any other I/O events. &lt;br> 3. Promise.resolve().then('B') is scheduled in the microtask queue, which runs after the nextTick queue. &lt;br> 4. setTimeout('A', 0) is scheduled in the macrotask (timer) queue, which runs on the next tick of the event loop, after all microtasks have finished."
,462. What is memoization? Implement a memoized function.,"Memoization is done with a higher-order function that takes a function (fn) to be memoized. It maintains a cache (like a Map) in its closure. It returns a new function that, when called, first creates a key from its arguments (e.g., by serializing them). It then checks if the key exists in the cache. If it does, it returns the cached result. If not, it calls the original function fn, stores the result in the cache with the new key, and then returns the result."
,463. How would you create a read-only property on an object?,"You would use the Object.defineProperty() static method. You pass it the target object, the name of the property as a string, and a ""property descriptor"" object. To make the property read-only, you set the writable key in the descriptor object to false."
,464. What is function currying? Provide an example.,"Currying is the process of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument. For example, a function add(a, b) that adds two numbers would be transformed into a function curriedAdd(a) which returns a new function. This new function then takes the argument b and returns the sum of a and b. This allows for creating specialized functions, like an addFive function, by just calling curriedAdd(5)."
,465. How does this binding work? Explain the differences with arrow functions.,"The value of this depends on how a function is called. In a method, this is the object. In a simple function call, it's the global object (or undefined in strict mode). call(), apply(), and bind() can explicitly set this. Arrow functions are different: they do not have their own this. Instead, they inherit this from their parent scope (lexical this)."
,466. What is prototypal inheritance?,"It's the mechanism in JavaScript where objects can inherit properties and methods directly from other objects. Every object has a private [[Prototype]] link to another object. When a property is accessed, the engine checks the object first, and if it's not found, it follows the prototype chain until it finds the property or reaches null."
,467. How would you implement a rate limiter for an API endpoint from scratch?,"This would be implemented as an Express middleware. The core logic would use a Map to store client IP addresses as keys. The values would be objects containing a request count and a reset timestamp. On each request, the middleware would look up the IP, increment its count, and check if the count exceeds a defined limit within the time window. If the limit is exceeded, it sends a 429 ""Too Many Requests"" error; otherwise, it calls next() to proceed."
,468. Explain the Singleton pattern and implement one in Node.js.,"The Singleton pattern ensures a class has only one instance and provides a global access point to it. In Node.js, the module system's cache provides a natural way to achieve this. The pattern is to define a class in a module, create a single instance of that class within the same module file, and then export that instance directly using module.exports. Any other module that requires this file will always receive the exact same cached instance."
,469. What is the Observer pattern? How does it relate to EventEmitter?,"The Observer pattern is a design pattern where a ""subject"" object maintains a list of ""observer"" objects and notifies them of any state changes. Node.js's EventEmitter class is a classic implementation of this pattern. The EventEmitter is the subject, on() registers an observer (a listener), and emit() notifies the observers of an event."
,470. Write a script to connect to a PostgreSQL database and execute a simple query.,"The process involves first requiring the pg library. Then, you would create a new Client instance, passing it a configuration object containing connection details like user, host, database, and password. You would then call the asynchronous connect method on the client. Once connected, you can execute a query using the query method with an SQL string. The result is an object containing the returned rows. Finally, you must call the end method to close the connection."
,471. What is the purpose of npm shrinkwrap? How does it relate to package-lock.json?,"npm shrinkwrap creates an npm-shrinkwrap.json file, which is functionally identical to package-lock.json. The key difference is its purpose: package-lock.json is for applications and is ignored when your project is installed as a dependency. npm-shrinkwrap.json is published with your package, ensuring that consumers of your library get the exact same dependency tree you developed with."
,472. How do you debug Node.js applications in a Docker container?,"1. Expose the Inspector Port: Run your Node.js app with the --inspect=0.0.0.0:9229 flag. 2. Map the Port: When running the container, map the host port to the container's inspector port: docker run -p 9229:9229 my-node-app. 3. Connect Debugger: Use a debugger (like in VS Code or Chrome DevTools) to connect to localhost:9229 on your host machine."
,473. What is an AbortController and how can it be used with fetch or other async operations?,"An AbortController is an API for creating a signal that can be used to abort an asynchronous operation. You create a controller, pass its signal property to an API like fetch, and then you can call the controller's abort() method to cancel the operation, which is useful for cleaning up requests that are no longer needed."
,474. What is the difference between a hard link and a symbolic link in the context of file systems?,"A symbolic link (or symlink) is a shortcut that points to another file's path. If the original file is deleted, the symlink is broken. A hard link is a direct reference to the data on disk (the inode). A file is only deleted when its last hard link is removed. Hard links cannot point to directories or span different file systems."
,475. How does Node.js handle top-level variable declarations in modules to prevent global scope pollution?,"Node.js wraps every module's code in a function before executing it (the ""module wrapper""). This function provides arguments like exports, require, module, etc. Because the code runs inside this function wrapper, any top-level variables are scoped to the module itself, not to the global object, preventing scope pollution."
,"476. Explain the concept of a ""side effect"" in a function. Why is it important in Node.js?","A side effect is any effect a function has beyond returning a value, such as modifying a global variable, writing to a file, or logging to the console. Understanding side effects is crucial in Node.js for predictability and debugging. Pure functions (without side effects) are easier to test and reason about, especially in an asynchronous, event-driven environment."
,477. What is Buffer.concat and what problem does it solve when reading from a stream?,"When reading from a stream (e.g., a TCP socket or a file), data often arrives in chunks. Buffer.concat() takes an array of Buffer instances and joins them into a single new Buffer. This solves the problem of reassembling fragmented data chunks into a complete message."
,478. How would you handle graceful restarts of your cluster workers to apply a patch without downtime?,"A common strategy is a ""rolling restart."" You would iterate through the cluster workers one by one: send a shutdown message to a worker, wait for it to finish its current requests and exit, then fork a new worker with the updated code. This ensures that there are always active workers available to handle requests, achieving zero-downtime deployment."
,479. Why is it generally a bad idea to block the event loop? Give three distinct examples of how you might accidentally do it.,"Blocking the event loop is bad because it prevents Node.js from handling any other concurrent operations, making the entire application unresponsive. Examples: 1. Synchronous I/O: Using synchronous file system methods like fs.readFileSync() on large files. 2. Complex Calculations: Running a long, CPU-intensive loop (e.g., calculating a large Fibonacci number) in the main thread. 3. Inefficient Regex: Using a poorly written regular expression that can lead to ""catastrophic backtracking"" on certain inputs."
,480. What is the Proxy object in ES6? Give a practical use case.,"A Proxy object allows you to create a wrapper around another object, which can intercept and redefine fundamental operations for that object (like getting or setting properties). A practical use case is for validation: you can create a proxy for an object that throws an error if a new property value doesn't conform to a specific schema."
,481. What is the Reflect API in ES6?,"The Reflect API is a built-in object that provides methods for interceptable JavaScript operations. Its methods correspond to the ""traps"" available for Proxy handlers (e.g., Reflect.get(), Reflect.set()). It provides a default, standard way to perform these operations, which is especially useful when forwarding operations inside a Proxy handler."
,482. What is tail-call optimization? Does V8 support it?,"Tail-call optimization (TCO) is a process where a compiler can optimize certain recursive function calls to avoid growing the call stack, preventing stack overflow errors for deep recursion. As of now, V8 (the engine behind Node.js and Chrome) does not support TCO in non-strict mode, and its support in strict mode has been removed due to implementation complexities."
,483. How would you prevent a Regular Expression Denial of Service (ReDoS) attack?,"A ReDoS attack uses a specially crafted string that forces a poorly written regex to take an extremely long time to execute, blocking the event loop. To prevent it: 1. Avoid Nested Quantifiers: Be wary of patterns like (a+)+. 2. Use Atomic Groups if the regex engine supports them. 3. Use a Linter: Employ static analysis tools that can detect vulnerable regex patterns. 4. Set Timeouts: Run the regex in a separate worker thread with a timeout."
,484. What is npm link and what problem does it solve during development?,npm link is a command-line tool that allows you to create a symbolic link from your global node_modules directory to a local package. This is useful when you are developing a package and want to test it in another project without having to publish it to the npm registry first. It solves the problem of local package development and testing.
,485. Explain how you would use async_hooks to track the lifecycle of an HTTP request.,"async_hooks is a core Node.js module that provides an API for tracking asynchronous resources. You can create a hook with callbacks (init, before, after, destroy) that fire as resources like promises or TCP sockets are created and completed. To track an HTTP request, you can use a tool like AsyncLocalStorage (built on async_hooks) to store a unique request ID when the request starts and access that ID in any subsequent async operation within that request's context."
,486. What is require.resolve used for?,"require.resolve('module') does not load the module but instead returns the resolved absolute file path of that module. It's useful for checking if a module exists without executing it or for getting a path to a module's file to use with other tools (e.g., a file reader)."
,"487. How does the module wrapper function in Node.js look, and what does it provide to your module's code?","The wrapper function looks like this: (function(exports, require, module, __filename, __dirname) { ... your module code ... });. It provides five key arguments to your module: exports, require, module, __filename (the absolute path to the file), and __dirname (the absolute path to the directory)."
,488. What is the NODE_PATH environment variable? What are its pros and cons?,"NODE_PATH is an environment variable that can be set to a colon-separated list of directories where Node.js should look for modules if they aren't found in node_modules. Pros: Can simplify require paths in some project structures. Cons: It's not a standard practice, can make dependency management less clear, and is generally discouraged in favor of local node_modules installations."
,489. Describe the difference between child_process.fork() and worker_threads.Worker.,"child_process.fork() spawns a completely new Node.js process, with its own memory and event loop. It's heavier and communication is done via IPC. worker_threads.Worker creates a thread within the same process. Threads share memory space, making them more lightweight and allowing for more efficient communication and data sharing (e.g., with SharedArrayBuffer)."
,"490. How can you make a Node.js process listen on a privileged port (e.g., 80) without running as root?","1. Reverse Proxy: The best practice is to run the Node.js app on a non-privileged port (e.g., 3000) and use a web server like Nginx or a load balancer as a reverse proxy to forward traffic from port 80 to port 3000. 2. authbind: Use a tool like authbind which allows non-root users to bind to privileged ports. 3. setcap: Use the Linux setcap command to grant the node executable the capability to bind to privileged ports without running the whole process as root."
,491. You're building an application that needs to be highly available. What does that mean to you in the context of Node.js?,"High availability means the application remains operational and responsive to users even in the face of failures. In Node.js, this means: 1. No Single Point of Failure: Using the cluster module or a process manager like PM2 to run multiple instances and automatically restart them if they crash. 2. Fault Tolerance: Gracefully handling errors and exceptions to prevent crashes. 3. Scalability: Deploying the application behind a load balancer to distribute traffic across multiple servers. 4. Zero-Downtime Deployments: Implementing a strategy (like rolling restarts) to update the application without interrupting service."
,492. What are your thoughts on using ORMs vs. writing raw SQL queries?,"ORMs (Object-Relational Mapping), like Sequelize or TypeORM, are great for rapid development, database abstraction, and preventing common SQL injection vulnerabilities. They are often easier to read and maintain for standard CRUD operations. Raw SQL provides maximum control and performance, which is essential for complex queries, bulk operations, or performance-critical paths. The choice depends on the project's complexity: a mix of both is often a pragmatic approach."
,493. What is the FinalizationRegistry object and what is it for?,"A FinalizationRegistry is an ES2021 feature that allows you to register a callback that will be invoked after an object has been garbage collected. Its primary use case is for cleaning up external resources (e.g., a file handle or a connection held in WebAssembly memory) that are associated with a JavaScript object, but without keeping the object itself alive just for the cleanup logic."
,494. How would you implement a feature flag system in a Node.js application?,"A simple implementation would involve a configuration file (e.g., a JSON file) that maps feature names to boolean values (true for on, false for off). The application would read this file at startup. In route handlers or service logic, you would check the flag: if (featureFlags.newCheckout) { ... } else { ... }. More advanced systems would use a service like LaunchDarkly or an internal dashboard to toggle flags in real-time without redeploying."
,495. What is the difference between Buffer and ArrayBuffer?,"Buffer is a Node.js-specific class for handling raw binary data. It's integrated with Node's APIs and is optimized for server-side operations. ArrayBuffer is a standard JavaScript object representing a generic, fixed-length chunk of binary data. It cannot be manipulated directly; you need to use a ""view"" object like Uint8Array or DataView to interact with its contents."
,"496. Explain the concept of ""Infrastructure as Code"" (IaC) and how it might apply to a Node.js project.","Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure (like servers, load balancers, and databases) through machine-readable definition files, rather than manual configuration. For a Node.js project, you could use a tool like Terraform or AWS CloudFormation to define the cloud services your application needs. This allows for automated, repeatable, and version-controlled setup of your production environment."
,497. What is dns.lookup() vs dns.resolve()?,"dns.lookup() uses the underlying operating system's resolver facilities (which may involve the hosts file). It almost always resolves a domain to an IPv4 address. dns.resolve() always performs a DNS query to a DNS server and can be used to get specific record types (e.g., MX, TXT). You should generally use dns.lookup() for connecting to services, as it respects the local system's configuration."
,498. Why is it important to sanitize user input? Where should this be done?,"It's crucial to sanitize user input to prevent security vulnerabilities, primarily Cross-Site Scripting (XSS) and SQL Injection. XSS occurs when malicious scripts are injected into the front end, while SQL Injection targets the database. Sanitization should be done on the server-side as a primary defense. You should validate data for correct type and format upon receiving it and escape data before rendering it in a view or including it in a database query."
,499. Describe a scenario where you would choose Node.js for a new project.,"I would choose Node.js for a project that is I/O-intensive and requires handling many concurrent connections with low latency. A great example would be a real-time chat application, a collaborative productivity tool, or a microservice API gateway that primarily shuffles data between other services. Its event-driven, non-blocking model excels in these scenarios."
,500. Describe a scenario where you would not choose Node.js for a new project.,"I would not choose Node.js for a project that is heavily CPU-bound. For example, a service designed for intensive scientific computing, heavy video encoding, or complex machine learning model training would be better suited for a language with strong multi-threading capabilities and performance characteristics for raw computation, such as Python (with its scientific libraries), Go, or C++."